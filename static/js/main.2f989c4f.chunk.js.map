{"version":3,"sources":["Cell/index.js","Algorithms/cleaning.js","Algorithms/methods.js","Algorithms/mazes/animations.js","Algorithms/mazes/default.js","Algorithms/mazes/prim.js","Algorithms/mazes/iterativeDF.js","Algorithms/mazes/recursiveDF.js","Algorithms/mazes/aldousBroder.js","Algorithms/mazes/kruskal.js","Algorithms/mazes/wilson.js","Algorithms/mazes/recursiveDivision.js","Algorithms/mazes/basicHorizontal.js","Algorithms/mazes/basicVertical.js","Algorithms/mazes/binaryTree.js","Algorithms/mazes/eller.js","Algorithms/searchers/animations.js","Algorithms/searchers/dijsktra.js","Algorithms/searchers/astar.js","Grid/index.js","App.js","index.js"],"names":["getColor","props","data","start","end","Cell","className","id","row","col","onMouseDown","e","preventDefault","onMouseEnter","onMouseUp","onContextMenu","distance","Infinity","clearWithStatus","type","clearVisitedCells","window","gridComponent","setState","grid","createGrid","startRow","startR","startCol","startC","endRow","endR","endCol","endC","state","cell","visualizeCell","clearBoard","status","newGrid","i","rows","j","columns","visited","previous","f","g","h","neighbors","isWall","clearInfinityVariables","push","direction","getCellsInOrder","endCell","cells","unshift","placeWall","newCell","doAlgorithm","category","name","document","getElementById","visualizeOnWalledGrid","path","setTimeout","length","a","currentPath","isOptimalPath","Promise","r","visualizeOnEmptyGrid","getRandomMazedGrid","numberOfCells","wallAmount","Math","floor","random","visualizeRandom","getNeighboringWalls","wallPairs","neighbor","takeRandomPair","position","pair","splice","takeLastCell","cellsWithUnvisitedNeighbors","getNeighboringCells","neighboringUnvisitedPairs","recursiveMaze","originalGrid","JSON","parse","stringify","recursion","currentCell","randomPair","aldousBroderMaze","unvisitedCells","visualizationList","current","filter","item","visualizeABMaze","kruskalMaze","idCounter","validWalls","map","Map","set","getSurroundingCells","array","temp","shuffleArray","wall","first","get","second","forEach","value","key","includes","wilsonMaze","newPath","takeRandomCell","aim","nextCell","removeCycle","visualizeWilson","clearDirections","recursiveDivision","middle","leftIndex","rightIndex","drawEdges","topLeft","topRight","bottomLeft","bottomRight","width","height","randomPosition","getMiddleLine","getRandomPosition","verticalLeft","verticalRight","horizontalTop","horizontalBottom","reference","half","ceil","size","num","basicHorizontal","exc","basicVertical","binaryTreeAlg","updateCells","getDirection","param1","param2","some","animatePathSlow","cellsInOrder","previousVisualization","animatePathFast","getUnvisitedNeighbors","isDiagonalOn","Up","Right","Down","Left","UpRight","RightDown","DownLeft","LeftUp","DoAnimation","visitedCells","speed","animateSlow","animateFast","astar","startCell","optimized","findNeighbors","openSet","cameFrom","allSet","heuristic","console","log","eliminateFromSet","k","tentative_gScore","dScore","slice","cell1","cell2","SQRT2","abs","sqrt","closedSet","animateAstarSlow","animateAstarFast","Grid","isMouseDown","isStartOn","isEndOn","currentAlg","previousRow","sort","shift","dijkstra","diagonalVisualization","optimizedVisualization","currentMaze","handleAlgoChange","bind","handleButtonChange","handleMazeChange","event","this","target","currentPair","primMaze","iterativeMaze","counter","delete","ellerMaze","index","cellIndex","onMouseLeave","onChange","disabled","onClick","defaultChecked","hidden","label","Component","App","getPosition","parameter","getSize","x","innerHeight","toFixed","innerWidth","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.2f989c4f.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./index.css\";\r\nfunction getColor(props) {\r\n  if (props.data.start) {\r\n    return \"cell-start\";\r\n  } else if (props.data.end) {\r\n    return \"cell-end\";\r\n  }else {\r\n    return \"\";\r\n  }\r\n}\r\n\r\nconst Cell = (props) => {\r\n  return (\r\n    <div\r\n      className={`cell ${getColor(props)}`}\r\n      id={`cell-${props.data.row}-${props.data.col}`}\r\n      onMouseDown={(e) => {\r\n        e.preventDefault();\r\n        props.onMouseDown(props.data);\r\n      }}\r\n      onMouseEnter={() => props.onMouseEnter(props.data)}\r\n      onMouseUp={() => props.onMouseUp(props.data)}\r\n      onContextMenu={(e) => {\r\n        e.preventDefault();\r\n      }}\r\n    >\r\n      <div\r\n        className={`num ${\"\"}`}\r\n        id={`num-${props.data.row}-${props.data.col}`}\r\n      >\r\n        {props.data.distance === Infinity ? \"\" : props.data.distance}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Cell;\r\n","import { visualizeCell, createGrid } from \"../Algorithms/methods\";\r\n\r\nexport function clearWithStatus(type) {\r\n  if (type === \"path\") {\r\n    clearVisitedCells();\r\n  } else if (type === \"grid\") {\r\n    clearBoard(window.gridComponent.props);\r\n  }\r\n  window.gridComponent.setState({ status: \"pending\" });\r\n}\r\n\r\nexport function clearVisitedCells() {\r\n  let newGrid = window.gridComponent.state.grid;\r\n  for (let i = 0; i < window.gridComponent.props.rows; i++) {\r\n    for (let j = 0; j < window.gridComponent.props.columns; j++) {\r\n      let cell = newGrid[i][j];\r\n      cell.visited = false;\r\n      cell.distance = Infinity;\r\n      cell.previous = null;\r\n      cell.f = Infinity;\r\n      cell.g = Infinity;\r\n      cell.h = Infinity;\r\n      cell.neighbors = [];\r\n\r\n      visualizeCell(\"num\", \"num\", cell);\r\n      if (!cell.isWall && !cell.end && !cell.start) {\r\n        visualizeCell(\"cell\", \"cell cell-empty\", cell);\r\n      }\r\n      if (cell.isWall && !cell.end && !cell.start) {\r\n        visualizeCell(\"cell\", \"cell cell-wall\", cell);\r\n      }\r\n    }\r\n  }\r\n  window.gridComponent.setState({ grid: newGrid });\r\n}\r\n\r\nexport function clearBoard(props) {\r\n  clearVisitedCells();\r\n  window.gridComponent.setState({\r\n    grid: createGrid(props),\r\n    startRow: props.startR,\r\n    startCol: props.startC,\r\n    endRow: props.endR,\r\n    endCol: props.endC,\r\n  });\r\n  for (const row of window.gridComponent.state.grid) {\r\n    for (const cell of row) {\r\n      if (!cell.end && !cell.start) {\r\n        visualizeCell(\"cell\", \"cell cell-empty\", cell);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function clearInfinityVariables(grid) {\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.distance = Infinity;\r\n      cell.f = Infinity;\r\n      cell.g = Infinity;\r\n      cell.h = Infinity;\r\n      cell.visited = false;\r\n      cell.id = 0;\r\n    }\r\n  }\r\n  window.gridComponent.setState({ grid: grid });\r\n}\r\n","import { clearVisitedCells } from \"../Algorithms/cleaning\";\r\n\r\nexport function createGrid(props) {\r\n  let grid = [];\r\n\r\n  for (let i = 0; i < props.rows; i++) {\r\n    grid.push([]);\r\n    for (let j = 0; j < props.columns; j++) {\r\n      grid[i].push({\r\n        id: 0,\r\n        row: i,\r\n        col: j,\r\n        start: false,\r\n        end: false,\r\n        distance: Infinity,\r\n        visited: false,\r\n        isWall: false,\r\n        previous: null,\r\n        direction: \"\",\r\n        //TODO: ASTAR scenario (this variables shall be handled differently later)\r\n        f: Infinity,\r\n        g: Infinity,\r\n        h: Infinity,\r\n        neighbors: [],\r\n      });\r\n    }\r\n  }\r\n\r\n  grid[props.startR][props.startC].start = true;\r\n  grid[props.endR][props.endC].end = true;\r\n\r\n  return grid;\r\n}\r\n\r\nexport function getCellsInOrder(endCell) {\r\n  const cells = [];\r\n  let cell = endCell;\r\n  while (cell !== null) {\r\n    cells.unshift(cell);\r\n    cell = cell.previous;\r\n  }\r\n  return cells;\r\n}\r\n\r\nexport function placeWall(cell) {\r\n  let newCell = cell;\r\n  let newGrid = window.gridComponent.state.grid;\r\n  newCell.isWall = !newCell.isWall;\r\n  if (newCell.isWall) {\r\n    visualizeCell(\"cell\", \"cell cell-wall-animated\", cell);\r\n  } else {\r\n    visualizeCell(\"cell\", \"cell cell-empty\", cell);\r\n    \r\n  }\r\n\r\n  visualizeCell(\"num\", \"num\", newCell);\r\n  newCell.visited = false;\r\n\r\n  newGrid[cell.row][cell.col] = newCell;\r\n  window.gridComponent.setState({ grid: newGrid }, () => {\r\n    if (window.gridComponent.state.status === \"finished\") {\r\n      clearVisitedCells();\r\n      window.gridComponent.doAlgorithm(\"fast\");\r\n    }\r\n  });\r\n}\r\n\r\nexport function visualizeCell(category, name, cell) {\r\n  document.getElementById(\r\n    `${category}-${cell.row}-${cell.col}`\r\n  ).className = name;\r\n}\r\n","import { visualizeCell } from \"../methods\";\r\nexport function visualizeOnWalledGrid(grid, path) {\r\n  window.gridComponent.setState({ status: \"running\" });\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      if (!cell.end && !cell.start) {\r\n        visualizeCell(\"cell\", \"cell cell-wall\", cell);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i <= path.length; i++) {\r\n    setTimeout(() => {\r\n      if (i === path.length) {\r\n        window.gridComponent.setState({ status: \"pending\" });\r\n        return;\r\n      }\r\n      if (!path[i].end && !path[i].start) {\r\n        visualizeCell(\"cell\", \"cell cell-empty\", path[i]);\r\n      }\r\n    }, 10 * i);\r\n  }\r\n}\r\n\r\nexport function visualizeRandom(grid, path) {\r\n  window.gridComponent.setState({ status: \"running\" });\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      if (!cell.end && !cell.start) {\r\n        visualizeCell(\"cell\", \"cell cell-empty\", cell);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i <= path.length; i++) {\r\n    setTimeout(() => {\r\n      if (i === path.length) {\r\n        window.gridComponent.setState({ status: \"pending\" });\r\n        return;\r\n      }\r\n      if (!path[i].end && !path[i].start) {\r\n        visualizeCell(\"cell\", \"cell cell-wall\", path[i]);\r\n      }\r\n    }, 8 * i);\r\n  }\r\n}\r\n\r\nexport function visualizeABMaze(grid, path) {\r\n  window.gridComponent.setState({ status: \"running\" });\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      if (!cell.end && !cell.start) {\r\n        visualizeCell(\"cell\", \"cell cell-wall\", cell);\r\n      }\r\n    }\r\n  }\r\n\r\n  var previous = null;\r\n  for (let i = 0; i <= path.length; i++) {\r\n    setTimeout(() => {\r\n      if (i === path.length) {\r\n        window.gridComponent.setState({ status: \"pending\" });\r\n        visualizeCell(\"cell\", \"cell cell-empty\", path[path.length - 1]);\r\n        return;\r\n      }\r\n      if (previous !== null) {\r\n        if (previous.isWall) {\r\n          visualizeCell(\"cell\", \"cell cell-wall\", previous);\r\n        } else {\r\n          visualizeCell(\"cell\", \"cell cell-empty\", previous);\r\n        }\r\n      }\r\n      if (!path[i].end && !path[i].start) {\r\n        visualizeCell(\"cell\", \"cell cell-current\", path[i]);\r\n        previous = path[i];\r\n      }\r\n    }, 10 * i);\r\n  }\r\n}\r\n\r\nexport async function visualizeWilson(grid, path) {\r\n  window.gridComponent.setState({ status: \"running\" });\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      if (!cell.end && !cell.start) {\r\n        visualizeCell(\"cell\", \"cell cell-wall\", cell);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i <= path.length; i++) {\r\n    if (i === path.length) {\r\n      window.gridComponent.setState({ status: \"pending\" });\r\n      return;\r\n    }\r\n    var previous = null;\r\n    var currentPath = path[i][0];\r\n    var isOptimalPath = path[i][1];\r\n    if (!isOptimalPath) {\r\n      for (let j = currentPath.length - 1; j > 0; j--) {\r\n        if (previous !== null) {\r\n          visualizeCell(\"cell\", \"cell cell-current\", previous);\r\n        }\r\n\r\n        if (!currentPath[j].end && !currentPath[j].start) {\r\n          visualizeCell(\"cell\", \"cell cell-previous\", currentPath[j]);\r\n          previous = currentPath[j];\r\n        }\r\n\r\n        if (currentPath[j] !== currentPath.length - 1) {\r\n          await new Promise((r) => setTimeout(r, 5));\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let j = 0; j < currentPath.length; j++) {\r\n      if (!currentPath[j].end && !currentPath[j].start) {\r\n        if (!isOptimalPath) {\r\n          visualizeCell(\"cell\", \"cell cell-wall\", currentPath[j]);\r\n        } else {\r\n          visualizeCell(\"cell\", \"cell cell-empty\", currentPath[j]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function visualizeOnEmptyGrid(grid, path) {\r\n  window.gridComponent.setState({ status: \"running\" });\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      if (!cell.end && !cell.start) {\r\n        visualizeCell(\"cell\", \"cell cell-empty\", cell);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i <= path.length; i++) {\r\n    setTimeout(() => {\r\n      if (i === path.length) {\r\n        window.gridComponent.setState({ status: \"pending\" });\r\n        return;\r\n      }\r\n      if (!path[i].end && !path[i].start) {\r\n        visualizeCell(\"cell\", \"cell cell-wall\", path[i]);\r\n      }\r\n    }, 10 * i);\r\n  }\r\n}\r\n","import { clearVisitedCells } from \"../../Algorithms/cleaning\";\r\nimport { visualizeRandom } from \"../mazes/animations\";\r\n\r\nexport function getRandomMazedGrid(grid) {\r\n  clearVisitedCells();\r\n  var path = [];\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.isWall = false;\r\n    }\r\n  }\r\n  var numberOfCells = (grid.length - 1) * (grid[0].length - 1);\r\n\r\n  var wallAmount = Math.floor(numberOfCells * 0.4); //0.4 should be later replaced with the amount\r\n\r\n  for (let i = 0; i < wallAmount; i++) {\r\n    let row = Math.floor(Math.random() * (grid.length - 1));\r\n    let col = Math.floor(Math.random() * (grid[0].length - 1));\r\n\r\n    let cell = grid[row][col];\r\n    if (cell.start || cell.end || cell.isWall) {\r\n      i--;\r\n    } else {\r\n      cell.isWall = true;\r\n      path.push(cell);\r\n    }\r\n  }\r\n  window.gridComponent.setState({ grid: grid });\r\n  visualizeRandom(grid, path);\r\n}\r\n","import {\r\n  clearWithStatus,\r\n  clearInfinityVariables,\r\n} from \"../../Algorithms/cleaning\";\r\nimport { visualizeOnWalledGrid } from \"../mazes/animations\";\r\nexport function primMaze(originalGrid) {\r\n  clearWithStatus(\"path\");\r\n  var grid = JSON.parse(JSON.stringify(originalGrid));\r\n  var path = [];\r\n  const wallPairs = [];\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.isWall = true;\r\n    }\r\n  }\r\n  getNeighboringWalls(grid[1][1], grid, wallPairs);\r\n  while (!!wallPairs.length) {\r\n    var currentPair = takeRandomPair(wallPairs);\r\n    if (!currentPair[1].isWall) {\r\n      continue;\r\n    }\r\n    currentPair[0].isWall = false;\r\n    currentPair[1].isWall = false;\r\n    path.push(currentPair[0]);\r\n    path.push(currentPair[1]);\r\n    getNeighboringWalls(currentPair[1], grid, wallPairs);\r\n  }\r\n  clearInfinityVariables(grid);\r\n  visualizeOnWalledGrid(grid, path);\r\n}\r\n\r\nfunction getNeighboringWalls(cell, grid, wallPairs) {\r\n  var { col, row } = cell;\r\n  if (row > 1) {\r\n    //UP\r\n    var neighbor = grid[row - 1][col];\r\n    wallPairs.push([neighbor, grid[row - 2][col]]);\r\n  }\r\n  if (col < grid[0].length - 2) {\r\n    //Right\r\n    let neighbor = grid[row][col + 1];\r\n    wallPairs.push([neighbor, grid[row][col + 2]]);\r\n  }\r\n  if (row < grid.length - 2) {\r\n    //Down\r\n    let neighbor = grid[row + 1][col];\r\n    wallPairs.push([neighbor, grid[row + 2][col]]);\r\n  }\r\n  if (col > 1) {\r\n    //Left\r\n    let neighbor = grid[row][col - 1];\r\n    wallPairs.push([neighbor, grid[row][col - 2]]);\r\n  }\r\n}\r\n\r\nfunction takeRandomPair(wallPairs) {\r\n  var position = Math.floor(Math.random() * wallPairs.length);\r\n  var pair = wallPairs[position];\r\n  wallPairs.splice(position, 1);\r\n  return pair;\r\n}\r\n","import {\r\n  clearWithStatus,\r\n  clearInfinityVariables,\r\n} from \"../cleaning\";\r\nimport { visualizeOnWalledGrid } from \"./animations\";\r\nexport function iterativeMaze(originalGrid) {\r\n  clearWithStatus(\"path\");\r\n  var path = [];\r\n  var grid = JSON.parse(JSON.stringify(originalGrid));\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.isWall = true;\r\n    }\r\n  }\r\n  var currentCell = grid[1][1];\r\n  currentCell.visited = true;\r\n  currentCell.isWall = false;\r\n  path.push(currentCell);\r\n  var cellsWithUnvisitedNeighbors = [];\r\n  cellsWithUnvisitedNeighbors.push(currentCell);\r\n\r\n  while (!!cellsWithUnvisitedNeighbors.length) {\r\n    currentCell = takeLastCell(cellsWithUnvisitedNeighbors);\r\n    var neighboringUnvisitedPairs = getNeighboringCells(currentCell, grid);\r\n    if (neighboringUnvisitedPairs.length > 0) {\r\n      cellsWithUnvisitedNeighbors.push(currentCell);\r\n      var randomPair =\r\n        neighboringUnvisitedPairs[\r\n          Math.floor(Math.random() * neighboringUnvisitedPairs.length)\r\n        ];\r\n      randomPair[0].isWall = false;\r\n      randomPair[1].isWall = false;\r\n      randomPair[1].visited = true;\r\n      path.push(randomPair[0]);\r\n      path.push(randomPair[1]);\r\n      cellsWithUnvisitedNeighbors.push(randomPair[1]);\r\n    }\r\n  }\r\n\r\n  clearInfinityVariables(grid);\r\n  window.gridComponent.setState({ grid: grid });\r\n  visualizeOnWalledGrid(grid, path);\r\n}\r\n\r\nfunction takeLastCell(cellsWithUnvisitedNeighbors) {\r\n  var position = cellsWithUnvisitedNeighbors.length - 1;\r\n  var cell = cellsWithUnvisitedNeighbors[position];\r\n  cellsWithUnvisitedNeighbors.splice(position, 1);\r\n  return cell;\r\n}\r\n\r\nfunction getNeighboringCells(cell, grid) {\r\n  var neighboringUnvisitedPairs = []; //pair[neighboringWall, neighbor]\r\n  var { col, row } = cell;\r\n  if (row > 1) {\r\n    //UP\r\n    var neighbor = grid[row - 1][col];\r\n    if (grid[row - 2][col].visited === false) {\r\n      neighboringUnvisitedPairs.push([neighbor, grid[row - 2][col]]);\r\n    }\r\n  }\r\n  if (col < grid[0].length - 2) {\r\n    //Right\r\n    let neighbor = grid[row][col + 1];\r\n    if (grid[row][col + 2].visited === false) {\r\n      neighboringUnvisitedPairs.push([neighbor, grid[row][col + 2]]);\r\n    }\r\n  }\r\n  if (row < grid.length - 2) {\r\n    //Down\r\n    let neighbor = grid[row + 1][col];\r\n    if (grid[row + 2][col].visited === false) {\r\n      neighboringUnvisitedPairs.push([neighbor, grid[row + 2][col]]);\r\n    }\r\n  }\r\n  if (col > 1) {\r\n    //Left\r\n    let neighbor = grid[row][col - 1];\r\n    if (grid[row][col - 2].visited === false) {\r\n      neighboringUnvisitedPairs.push([neighbor, grid[row][col - 2]]);\r\n    }\r\n  }\r\n\r\n  return neighboringUnvisitedPairs;\r\n}\r\n","import {\r\n  clearWithStatus,\r\n  clearInfinityVariables,\r\n} from \"../cleaning\";\r\nimport { visualizeOnWalledGrid } from \"./animations\";\r\nexport function recursiveMaze(originalGrid) {\r\n  clearWithStatus(\"path\");\r\n  var path = [];\r\n  var grid = JSON.parse(JSON.stringify(originalGrid));\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.isWall = true;\r\n    }\r\n  }\r\n  var currentCell = grid[1][1];\r\n  recursion(grid, currentCell, path);\r\n  clearInfinityVariables(grid);\r\n  window.gridComponent.setState({ grid: grid });\r\n  //visualization\r\n  visualizeOnWalledGrid(grid, path);\r\n}\r\n\r\nfunction recursion(grid, currentCell, path) {\r\n  currentCell.visited = true;\r\n  currentCell.isWall = false;\r\n  path.push(currentCell);\r\n  currentCell.neighbors = getNeighboringCells(currentCell, grid);\r\n  while (currentCell.neighbors.length > 0) {\r\n    var position = Math.floor(Math.random() * currentCell.neighbors.length);\r\n    var randomPair = currentCell.neighbors[position];\r\n    currentCell.neighbors.splice(position, 1);\r\n    if (!randomPair[1].visited) {\r\n      randomPair[0].isWall = false;\r\n      path.push(randomPair[0]);\r\n      recursion(grid, randomPair[1], path);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getNeighboringCells(cell, grid) {\r\n  var neighboringUnvisitedPairs = []; //pair[neighboringWall, neighbor]\r\n  var { col, row } = cell;\r\n  if (row > 1) {\r\n    //UP\r\n    var neighbor = grid[row - 1][col];\r\n    if (grid[row - 2][col].visited === false) {\r\n      neighboringUnvisitedPairs.push([neighbor, grid[row - 2][col]]);\r\n    }\r\n  }\r\n  if (col < grid[0].length - 2) {\r\n    //Right\r\n    let neighbor = grid[row][col + 1];\r\n    if (grid[row][col + 2].visited === false) {\r\n      neighboringUnvisitedPairs.push([neighbor, grid[row][col + 2]]);\r\n    }\r\n  }\r\n  if (row < grid.length - 2) {\r\n    //Down\r\n    let neighbor = grid[row + 1][col];\r\n    if (grid[row + 2][col].visited === false) {\r\n      neighboringUnvisitedPairs.push([neighbor, grid[row + 2][col]]);\r\n    }\r\n  }\r\n  if (col > 1) {\r\n    //Left\r\n    let neighbor = grid[row][col - 1];\r\n    if (grid[row][col - 2].visited === false) {\r\n      neighboringUnvisitedPairs.push([neighbor, grid[row][col - 2]]);\r\n    }\r\n  }\r\n\r\n  return neighboringUnvisitedPairs;\r\n}\r\n","import { visualizeABMaze } from \"../mazes/animations\";\r\nimport {\r\n  clearWithStatus,\r\n  clearInfinityVariables,\r\n} from \"../../Algorithms/cleaning\";\r\n\r\nexport function aldousBroderMaze(originalGrid) {\r\n  clearWithStatus(\"path\");\r\n  var grid = JSON.parse(JSON.stringify(originalGrid));\r\n  var unvisitedCells = [];\r\n  var visualizationList = [];\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.isWall = true;\r\n      if (cell.row % 2 === 1 && cell.col % 2 === 1) {\r\n        cell.id = unvisitedCells.length;\r\n        unvisitedCells.push(cell);\r\n        getNeighboringCells(cell, grid);\r\n      }\r\n    }\r\n  }\r\n\r\n  var current = unvisitedCells[0];\r\n  unvisitedCells.splice(0, 1);\r\n  current.visited = true;\r\n  current.isWall = false;\r\n\r\n  while (!!unvisitedCells.length) {\r\n    const neighbor =\r\n      current.neighbors[Math.floor(Math.random() * current.neighbors.length)];\r\n    visualizationList.push(neighbor[0]);\r\n    visualizationList.push(neighbor[1]);\r\n    if (!neighbor[1].visited) {\r\n      neighbor[0].isWall = false;\r\n      neighbor[1].isWall = false;\r\n      unvisitedCells = unvisitedCells.filter(\r\n        (item) => item.id !== neighbor[1].id\r\n      );\r\n      neighbor[1].visited = true;\r\n    }\r\n    current = neighbor[1];\r\n  }\r\n  clearInfinityVariables(grid);\r\n  window.gridComponent.setState({ grid: grid });\r\n  visualizeABMaze(grid, visualizationList);\r\n}\r\n\r\n/*function takeRandomCell(unvisitedCells) {\r\n  var position = Math.floor(Math.random() * unvisitedCells.length);\r\n  var cell = unvisitedCells[0];\r\n  unvisitedCells.splice(0, 1);\r\n  return cell;\r\n}*/\r\n\r\nfunction getNeighboringCells(cell, grid) {\r\n  //pair[neighboringWall, neighbor]\r\n  var { col, row } = cell;\r\n  if (row > 1) {\r\n    //UP\r\n    var neighbor = grid[row - 1][col];\r\n    cell.neighbors.push([neighbor, grid[row - 2][col]]);\r\n  }\r\n  if (col < grid[0].length - 2) {\r\n    //Right\r\n    let neighbor = grid[row][col + 1];\r\n    cell.neighbors.push([neighbor, grid[row][col + 2]]);\r\n  }\r\n  if (row < grid.length - 2) {\r\n    //Down\r\n    let neighbor = grid[row + 1][col];\r\n    cell.neighbors.push([neighbor, grid[row + 2][col]]);\r\n  }\r\n  if (col > 1) {\r\n    //Left\r\n    let neighbor = grid[row][col - 1];\r\n    cell.neighbors.push([neighbor, grid[row][col - 2]]);\r\n  }\r\n}\r\n","import {\r\n  clearWithStatus,\r\n  clearInfinityVariables,\r\n} from \"../../Algorithms/cleaning\";\r\nimport { visualizeOnWalledGrid } from \"../mazes/animations\";\r\nexport function kruskalMaze(originalGrid) {\r\n  clearWithStatus(\"path\");\r\n  var path = [];\r\n  var grid = JSON.parse(JSON.stringify(originalGrid));\r\n  var idCounter = 0;\r\n  var validWalls = [];\r\n  var map = new Map();\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.isWall = true;\r\n      if (cell.row % 2 === 1 && cell.col % 2 === 1) {\r\n        //CELLS\r\n        map.set(cell, idCounter++);\r\n      } else if (cell.row % 2 === 1 || cell.col % 2 === 1) {\r\n        if (\r\n          cell.row !== 0 &&\r\n          cell.col !== 0 &&\r\n          cell.row !== grid.length - 1 &&\r\n          cell.col !== grid[0].length - 1\r\n        ) {\r\n          //WALLS\r\n          getSurroundingCells(cell, grid);\r\n          validWalls.push(cell);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  shuffleArray(validWalls);\r\n\r\n  for (const wall of validWalls) {\r\n    const first = map.get(wall.neighbors[0]);\r\n    const second = map.get(wall.neighbors[1]);\r\n    if (first !== second) {\r\n      map.forEach((value, key) => {\r\n        if (value === second) {\r\n          map.set(key, first);\r\n        }\r\n      });\r\n\r\n      wall.neighbors[0].isWall = false;\r\n      wall.isWall = false;\r\n      wall.neighbors[1].isWall = false;\r\n\r\n      if (!path.includes(wall.neighbors[0])) path.push(wall.neighbors[0]);\r\n      if (!path.includes(wall)) path.push(wall);\r\n      if (!path.includes(wall.neighbors[1])) path.push(wall.neighbors[1]);\r\n    }\r\n  }\r\n  clearInfinityVariables(grid);\r\n  visualizeOnWalledGrid(grid, path);\r\n}\r\n\r\nfunction getSurroundingCells(wall, grid) {\r\n  var { col, row } = wall;\r\n  if (wall.row % 2 === 1) {\r\n    wall.neighbors.push(grid[row][col + 1]);\r\n    wall.neighbors.push(grid[row][col - 1]);\r\n  } else {\r\n    wall.neighbors.push(grid[row - 1][col]);\r\n    wall.neighbors.push(grid[row + 1][col]);\r\n  }\r\n}\r\n\r\nfunction shuffleArray(array) {\r\n  for (var i = array.length - 1; i > 0; i--) {\r\n    var j = Math.floor(Math.random() * (i + 1));\r\n    var temp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = temp;\r\n  }\r\n}\r\n","import {\r\n  clearWithStatus,\r\n  clearInfinityVariables,\r\n} from \"../../Algorithms/cleaning\";\r\nimport { visualizeWilson } from \"../mazes/animations\";\r\nexport function wilsonMaze(originalGrid) {\r\n  clearWithStatus(\"path\");\r\n  var path = [];\r\n  var unvisitedCells = [];\r\n  var grid = JSON.parse(JSON.stringify(originalGrid));\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.isWall = true;\r\n      if (cell.row % 2 === 1 && cell.col % 2 === 1) {\r\n        cell.id = unvisitedCells.length;\r\n        unvisitedCells.push(cell);\r\n        getNeighboringCells(cell, grid);\r\n      }\r\n    }\r\n  }\r\n  var newPath = [];\r\n  while (unvisitedCells.length >= 1) {\r\n    var start = takeRandomCell(unvisitedCells);\r\n    var aim = grid[1][1];\r\n    newPath = [];\r\n    var nextCell = start;\r\n    newPath.push(nextCell);\r\n    while (nextCell !== aim) {\r\n      var newCell =\r\n        nextCell.neighbors[\r\n          Math.floor(Math.random() * nextCell.neighbors.length)\r\n        ];\r\n\r\n      if (nextCell.visited) {\r\n        aim = nextCell;\r\n      } else {\r\n        nextCell.direction = newCell[2];\r\n        nextCell = newCell[1];\r\n        newPath.push(newCell[0]);\r\n        newPath.push(newCell[1]);\r\n      }\r\n    }\r\n    if (newPath.length > 1) {\r\n      path.push([newPath, false]);\r\n    }\r\n\r\n    removeCycle(nextCell, start, aim, grid, path);\r\n  }\r\n\r\n  clearInfinityVariables(grid);\r\n  window.gridComponent.setState({ grid: grid });\r\n  visualizeWilson(grid, path);\r\n}\r\nfunction clearDirections(grid) {\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.direction = \"\";\r\n    }\r\n  }\r\n}\r\n\r\nfunction takeRandomCell(unvisitedCells) {\r\n  var position = Math.floor(Math.random() * unvisitedCells.length);\r\n  var cell = unvisitedCells[position];\r\n  unvisitedCells.splice(position, 1);\r\n  return cell;\r\n}\r\n\r\nfunction removeCycle(nextCell, start, aim, grid, path) {\r\n  var newPath = [];\r\n  nextCell = start;\r\n  nextCell.visited = true;\r\n  nextCell.isWall = false;\r\n  newPath.push(nextCell);\r\n\r\n  while (nextCell !== aim) {\r\n    var { col, row } = nextCell;\r\n    if (nextCell.direction === \"UP\") {\r\n      grid[row - 1][col].isWall = false;\r\n      grid[row - 2][col].isWall = false;\r\n      grid[row - 2][col].visited = true;\r\n      nextCell = grid[row - 2][col];\r\n      newPath.push(grid[row - 1][col]);\r\n      newPath.push(grid[row - 2][col]);\r\n    } else if (nextCell.direction === \"DOWN\") {\r\n      grid[row + 1][col].isWall = false;\r\n      grid[row + 2][col].isWall = false;\r\n      grid[row + 2][col].visited = true;\r\n      nextCell = grid[row + 2][col];\r\n      newPath.push(grid[row + 1][col]);\r\n      newPath.push(grid[row + 2][col]);\r\n    } else if (nextCell.direction === \"RIGHT\") {\r\n      grid[row][col + 1].isWall = false;\r\n      grid[row][col + 2].isWall = false;\r\n      grid[row][col + 2].visited = true;\r\n      nextCell = grid[row][col + 2];\r\n      newPath.push(grid[row][col + 1]);\r\n      newPath.push(grid[row][col + 2]);\r\n    } else if (nextCell.direction === \"LEFT\") {\r\n      grid[row][col - 1].isWall = false;\r\n      grid[row][col - 2].isWall = false;\r\n      grid[row][col - 2].visited = true;\r\n      nextCell = grid[row][col - 2];\r\n      newPath.push(grid[row][col - 1]);\r\n      newPath.push(grid[row][col - 2]);\r\n    }\r\n  }\r\n  if (newPath.length > 1) {\r\n    path.push([newPath, true]);\r\n  }\r\n\r\n  clearDirections(grid);\r\n}\r\n\r\nfunction getNeighboringCells(cell, grid) {\r\n  //pair[neighboringWall, neighbor]\r\n  var { col, row } = cell;\r\n  if (row > 1) {\r\n    //UP\r\n    var neighbor = grid[row - 1][col];\r\n    cell.neighbors.push([neighbor, grid[row - 2][col], \"UP\"]);\r\n  }\r\n  if (col < grid[0].length - 2) {\r\n    //Right\r\n    let neighbor = grid[row][col + 1];\r\n    cell.neighbors.push([neighbor, grid[row][col + 2], \"RIGHT\"]);\r\n  }\r\n  if (row < grid.length - 2) {\r\n    //Down\r\n    let neighbor = grid[row + 1][col];\r\n    cell.neighbors.push([neighbor, grid[row + 2][col], \"DOWN\"]);\r\n  }\r\n  if (col > 1) {\r\n    //Left\r\n    let neighbor = grid[row][col - 1];\r\n    cell.neighbors.push([neighbor, grid[row][col - 2], \"LEFT\"]);\r\n  }\r\n}\r\n","import { clearWithStatus, clearInfinityVariables } from \"../cleaning\";\r\nimport { visualizeOnEmptyGrid } from \"./animations\";\r\nexport function recursiveDivision(originalGrid) {\r\n  clearWithStatus(\"path\");\r\n  var path = [];\r\n  var grid = JSON.parse(JSON.stringify(originalGrid));\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.isWall = false;\r\n    }\r\n  }\r\n  drawEdges(grid, path);\r\n  recursion(\r\n    grid[1][1],\r\n    grid[1][grid[1].length - 2],\r\n    grid[grid.length - 2][1],\r\n    grid[grid.length - 2][grid[1].length - 2],\r\n    grid,\r\n    path\r\n  );\r\n\r\n  clearInfinityVariables(grid);\r\n  window.gridComponent.setState({ grid: grid });\r\n  visualizeOnEmptyGrid(grid, path);\r\n}\r\n\r\nfunction drawEdges(grid, path) {\r\n  var middle = Math.floor(grid[0].length / 2);\r\n  var leftIndex = middle - 1;\r\n  var rightIndex = middle + 1;\r\n  path.push(grid[0][middle]);\r\n  grid[0][middle].isWall = true;\r\n  while (leftIndex >= 0) {\r\n    path.push(grid[0][leftIndex]);\r\n    path.push(grid[0][rightIndex]);\r\n    grid[0][leftIndex].isWall = true;\r\n    grid[0][rightIndex].isWall = true;\r\n    leftIndex--;\r\n    rightIndex++;\r\n  }\r\n  for (let i = 1; i < grid.length - 1; i++) {\r\n    path.push(grid[i][0]);\r\n    path.push(grid[i][grid[0].length - 1]);\r\n    grid[i][0].isWall = true;\r\n    grid[i][grid[0].length - 1].isWall = true;\r\n  }\r\n  leftIndex = 0;\r\n  rightIndex = grid[0].length - 1;\r\n\r\n  while (leftIndex !== middle) {\r\n    path.push(grid[grid.length - 1][leftIndex]);\r\n    path.push(grid[grid.length - 1][rightIndex]);\r\n    grid[grid.length - 1][leftIndex].isWall = true;\r\n    grid[grid.length - 1][rightIndex].isWall = true;\r\n    leftIndex++;\r\n    rightIndex--;\r\n  }\r\n  path.push(grid[grid.length - 1][middle]);\r\n  grid[grid.length - 1][middle].isWall = true;\r\n}\r\n\r\nfunction recursion(topLeft, topRight, bottomLeft, bottomRight, grid, path) {\r\n  var width = topRight.col - topLeft.col + 1;\r\n  var height = bottomLeft.row - topLeft.row + 1;\r\n  if (height < 3 || width < 3) return;\r\n\r\n  var middle = null;\r\n  var randomPosition = null;\r\n\r\n  if (width >= height) {\r\n    //Vertical\r\n    middle = getMiddleLine(width, topLeft.col);\r\n    randomPosition = getRandomPosition(height);\r\n\r\n    for (let i = topLeft.row; i < topLeft.row + height; i++) {\r\n      if (i !== topLeft.row + randomPosition - 1) {\r\n        path.push(grid[i][middle]);\r\n        grid[i][middle].isWall = true;\r\n      }\r\n    }\r\n    if (height < 4 && width < 4) {\r\n      return;\r\n    }\r\n    verticalLeft(grid, topLeft, bottomLeft, middle, path);\r\n    verticalRight(\r\n      grid,\r\n      topLeft,\r\n      topRight,\r\n      bottomLeft,\r\n      bottomRight,\r\n      middle,\r\n      path\r\n    );\r\n    return;\r\n  } else {\r\n    //Horizontal\r\n    middle = getMiddleLine(height, topLeft.row);\r\n    randomPosition = getRandomPosition(width);\r\n    for (let i = topLeft.col; i < topLeft.col + width; i++) {\r\n      if (i !== topLeft.col + randomPosition - 1) {\r\n        path.push(grid[middle][i]);\r\n        grid[middle][i].isWall = true;\r\n      }\r\n    }\r\n    if (height < 4 && width < 4) {\r\n      return;\r\n    }\r\n    horizontalTop(\r\n      grid,\r\n      topLeft,\r\n      topRight,\r\n      bottomLeft,\r\n      bottomRight,\r\n      middle,\r\n      path\r\n    );\r\n    horizontalBottom(grid, bottomLeft, bottomRight, middle, path);\r\n    return;\r\n  }\r\n}\r\n\r\nfunction verticalLeft(grid, topLeft, bottomLeft, middle, path) {\r\n  if (\r\n    grid[topLeft.row][middle - 1].col - topLeft.col > 0 &&\r\n    bottomLeft.row - topLeft.row > 0\r\n  ) {\r\n    recursion(\r\n      topLeft,\r\n      grid[topLeft.row][middle - 1],\r\n      bottomLeft,\r\n      grid[bottomLeft.row][middle - 1],\r\n      grid,\r\n      path\r\n    );\r\n  }\r\n  return;\r\n}\r\n\r\nfunction verticalRight(\r\n  grid,\r\n  topLeft,\r\n  topRight,\r\n  bottomLeft,\r\n  bottomRight,\r\n  middle,\r\n  path\r\n) {\r\n  if (\r\n    topRight.col - grid[topLeft.row][middle + 1].col > 0 &&\r\n    grid[bottomLeft.row][middle + 1].row - grid[topLeft.row][middle + 1].row > 0\r\n  ) {\r\n    recursion(\r\n      grid[topLeft.row][middle + 1],\r\n      topRight,\r\n      grid[bottomLeft.row][middle + 1],\r\n      bottomRight,\r\n      grid,\r\n      path\r\n    );\r\n  }\r\n  return;\r\n}\r\n\r\nfunction horizontalTop(\r\n  grid,\r\n  topLeft,\r\n  topRight,\r\n  bottomLeft,\r\n  bottomRight,\r\n  middle,\r\n  path\r\n) {\r\n  if (\r\n    topRight.col - topLeft.col > 0 &&\r\n    grid[middle - 1][bottomLeft.col].row - topLeft.row > 0\r\n  ) {\r\n    recursion(\r\n      topLeft,\r\n      topRight,\r\n      grid[middle - 1][bottomLeft.col],\r\n      grid[middle - 1][bottomRight.col],\r\n      grid,\r\n      path\r\n    );\r\n  }\r\n  return;\r\n}\r\n\r\nfunction horizontalBottom(grid, bottomLeft, bottomRight, middle, path) {\r\n  if (\r\n    grid[middle + 1][bottomRight.col].col -\r\n      grid[middle + 1][bottomLeft.col].col >\r\n      0 &&\r\n    bottomLeft.row - grid[middle + 1][bottomLeft.col].row > 0\r\n  ) {\r\n    recursion(\r\n      grid[middle + 1][bottomLeft.col],\r\n      grid[middle + 1][bottomRight.col],\r\n      bottomLeft,\r\n      bottomRight,\r\n      grid,\r\n      path\r\n    );\r\n  }\r\n  return;\r\n}\r\n\r\nfunction getMiddleLine(position, reference) {\r\n  var half = Math.ceil(position / 2);\r\n  half = half % 2 === 0 ? half : half + (Math.random() < 0.5 ? -1 : 1);\r\n  return half + reference - 1;\r\n}\r\n\r\nfunction getRandomPosition(size) {\r\n  var num = Math.floor(Math.random() * (size - 1 + 1)) + 1;\r\n  return num % 2 === 1 ? num : num + (Math.random() < 0.5 ? -1 : 1);\r\n}\r\n","import { clearWithStatus, clearInfinityVariables } from \"../cleaning\";\r\nimport { visualizeOnEmptyGrid } from \"./animations\";\r\nexport function basicHorizontal(originalGrid) {\r\n  clearWithStatus(\"path\");\r\n  var path = [];\r\n  var grid = JSON.parse(JSON.stringify(originalGrid));\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.isWall = false;\r\n    }\r\n  }\r\n  drawEdges(grid, path);\r\n  for (let i = 2; i < grid.length - 1; i += 2) {\r\n    var exc = Math.floor(Math.random() * (grid[0].length - 2 - 1 + 1)) + 1;\r\n    if (i % 4 === 0) {\r\n      for (let j = grid[0].length - 2; j > 0; j--) {\r\n        if (j === exc) continue;\r\n        path.push(grid[i][j]);\r\n        grid[i][j].isWall = true;\r\n      }\r\n    } else {\r\n      for (let j = 1; j < grid[0].length - 1; j++) {\r\n        if (j === exc) continue;\r\n        path.push(grid[i][j]);\r\n        grid[i][j].isWall = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  clearInfinityVariables(grid);\r\n  window.gridComponent.setState({ grid: grid });\r\n  visualizeOnEmptyGrid(grid, path);\r\n}\r\n\r\nfunction drawEdges(grid, path) {\r\n  var middle = Math.floor(grid[0].length / 2);\r\n  var leftIndex = middle - 1;\r\n  var rightIndex = middle + 1;\r\n  path.push(grid[0][middle]);\r\n  grid[0][middle].isWall = true;\r\n  while (leftIndex >= 0) {\r\n    path.push(grid[0][leftIndex]);\r\n    path.push(grid[0][rightIndex]);\r\n    grid[0][leftIndex].isWall = true;\r\n    grid[0][rightIndex].isWall = true;\r\n    leftIndex--;\r\n    rightIndex++;\r\n  }\r\n  for (let i = 1; i < grid.length - 1; i++) {\r\n    path.push(grid[i][0]);\r\n    path.push(grid[i][grid[0].length - 1]);\r\n    grid[i][0].isWall = true;\r\n    grid[i][grid[0].length - 1].isWall = true;\r\n  }\r\n  leftIndex = 0;\r\n  rightIndex = grid[0].length - 1;\r\n\r\n  while (leftIndex !== middle) {\r\n    path.push(grid[grid.length - 1][leftIndex]);\r\n    path.push(grid[grid.length - 1][rightIndex]);\r\n    grid[grid.length - 1][leftIndex].isWall = true;\r\n    grid[grid.length - 1][rightIndex].isWall = true;\r\n    leftIndex++;\r\n    rightIndex--;\r\n  }\r\n  path.push(grid[grid.length - 1][middle]);\r\n  grid[grid.length - 1][middle].isWall = true;\r\n}\r\n","import { clearWithStatus, clearInfinityVariables } from \"../cleaning\";\r\nimport { visualizeOnEmptyGrid } from \"./animations\";\r\nexport function basicVertical(originalGrid) {\r\n  clearWithStatus(\"path\");\r\n  var path = [];\r\n  var grid = JSON.parse(JSON.stringify(originalGrid));\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.isWall = false;\r\n    }\r\n  }\r\n  drawEdges(grid, path);\r\n  for (let i = 2; i < grid[0].length - 1; i += 2) {\r\n    var exc = Math.floor(Math.random() * (grid.length - 2 - 1 + 1)) + 1;\r\n    if (i % 4 === 0) {\r\n      for (let j = grid.length - 2; j > 0; j--) {\r\n        if (j === exc) continue;\r\n        path.push(grid[j][i]);\r\n        grid[j][i].isWall = true;\r\n      }\r\n    } else {\r\n      for (let j = 1; j < grid.length - 1; j++) {\r\n        if (j === exc) continue;\r\n        path.push(grid[j][i]);\r\n        grid[j][i].isWall = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  clearInfinityVariables(grid);\r\n  window.gridComponent.setState({ grid: grid });\r\n  visualizeOnEmptyGrid(grid, path);\r\n}\r\n\r\nfunction drawEdges(grid, path) {\r\n  var middle = Math.floor(grid[0].length / 2);\r\n  var leftIndex = middle - 1;\r\n  var rightIndex = middle + 1;\r\n  path.push(grid[0][middle]);\r\n  grid[0][middle].isWall = true;\r\n  while (leftIndex >= 0) {\r\n    path.push(grid[0][leftIndex]);\r\n    path.push(grid[0][rightIndex]);\r\n    grid[0][leftIndex].isWall = true;\r\n    grid[0][rightIndex].isWall = true;\r\n    leftIndex--;\r\n    rightIndex++;\r\n  }\r\n  for (let i = 1; i < grid.length - 1; i++) {\r\n    path.push(grid[i][0]);\r\n    path.push(grid[i][grid[0].length - 1]);\r\n    grid[i][0].isWall = true;\r\n    grid[i][grid[0].length - 1].isWall = true;\r\n  }\r\n  leftIndex = 0;\r\n  rightIndex = grid[0].length - 1;\r\n\r\n  while (leftIndex !== middle) {\r\n    path.push(grid[grid.length - 1][leftIndex]);\r\n    path.push(grid[grid.length - 1][rightIndex]);\r\n    grid[grid.length - 1][leftIndex].isWall = true;\r\n    grid[grid.length - 1][rightIndex].isWall = true;\r\n    leftIndex++;\r\n    rightIndex--;\r\n  }\r\n  path.push(grid[grid.length - 1][middle]);\r\n  grid[grid.length - 1][middle].isWall = true;\r\n}\r\n","import { clearWithStatus, clearInfinityVariables } from \"../cleaning\";\r\nimport { visualizeOnWalledGrid } from \"./animations\";\r\nexport function binaryTreeAlg(originalGrid, direction) {\r\n  clearWithStatus(\"path\");\r\n \r\n  var path = [];\r\n  var grid = JSON.parse(JSON.stringify(originalGrid));\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.isWall = true;\r\n    }\r\n  }\r\n\r\n  getDirection(direction, grid, path);\r\n\r\n  clearInfinityVariables(grid);\r\n  window.gridComponent.setState({ grid: grid });\r\n  visualizeOnWalledGrid(grid, path);\r\n}\r\n\r\nfunction getDirection(direction, grid, path) {\r\n  var id = 0;\r\n  if (direction === \"NorthWest\") {\r\n    for (let i = grid.length - 2; i > 0; i -= 2) {\r\n      for (let j = grid[0].length - 2; j > 0; j -= 2) {\r\n        updateCells(grid, grid[i][j], path, \"North\", \"West\", id);\r\n      }\r\n    }\r\n  } else if (direction === \"NorthEast\") {\r\n    for (let i = grid.length - 2; i > 0; i -= 2) {\r\n      for (let j = 1; j < grid[0].length; j += 2) {\r\n        updateCells(grid, grid[i][j], path, \"North\", \"East\", id);\r\n      }\r\n    }\r\n  } else if (direction === \"SouthWest\") {\r\n    for (let i = 1; i < grid.length; i += 2) {\r\n      for (let j = grid[0].length - 2; j > 0; j -= 2) {\r\n        updateCells(grid, grid[i][j], path, \"South\", \"West\", id);\r\n      }\r\n    }\r\n  } else if (direction === \"SouthEast\") {\r\n    for (let i = 1; i < grid.length; i += 2) {\r\n      for (let j = 1; j < grid[0].length; j += 2) {\r\n        updateCells(grid, grid[i][j], path, \"South\", \"East\", id);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction updateCells(grid, current, path, param1, param2, id) {\r\n  current.isWall = false;\r\n  path.push(current);\r\n\r\n  getNeighboringCells(current, grid, param1, param2);\r\n  current.id = id;\r\n  id++;\r\n  if (current.neighbors.length !== 0) {\r\n    const neighbor =\r\n      current.neighbors[Math.floor(Math.random() * current.neighbors.length)];\r\n\r\n    neighbor[0].isWall = false;\r\n    path.push(neighbor[0]);\r\n\r\n    if (!path.some((e) => e.id === neighbor[1].id)) {\r\n      neighbor[1].isWall = false;\r\n      path.push(neighbor[1]);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getNeighboringCells(cell, grid, param1, param2) {\r\n  //pair[neighboringWall, neighbor]\r\n  var { col, row } = cell;\r\n  if (row > 1 && (param1 === \"North\" || param2 === \"North\")) {\r\n    //UP\r\n    var neighbor = grid[row - 1][col];\r\n    cell.neighbors.push([neighbor, grid[row - 2][col]]);\r\n  }\r\n  if (col < grid[0].length - 2 && (param1 === \"East\" || param2 === \"East\")) {\r\n    //Right\r\n    let neighbor = grid[row][col + 1];\r\n    cell.neighbors.push([neighbor, grid[row][col + 2]]);\r\n  }\r\n  if (row < grid.length - 2 && (param1 === \"South\" || param2 === \"South\")) {\r\n    //Down\r\n    let neighbor = grid[row + 1][col];\r\n    cell.neighbors.push([neighbor, grid[row + 2][col]]);\r\n  }\r\n  if (col > 1 && (param1 === \"West\" || param2 === \"West\")) {\r\n    //Left\r\n    let neighbor = grid[row][col - 1];\r\n    cell.neighbors.push([neighbor, grid[row][col - 2]]);\r\n  }\r\n}\r\n","import { clearWithStatus, clearInfinityVariables } from \"../cleaning\";\r\nimport { visualizeOnWalledGrid } from \"./animations\";\r\nexport function ellerMaze(originalGrid) {\r\n  clearWithStatus(\"path\");\r\n  var path = [];\r\n  var grid = JSON.parse(JSON.stringify(originalGrid));\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.isWall = true;\r\n    }\r\n  }\r\n  var idCounter = 1;\r\n  for (let i = 1; i < grid.length; i += 2) {\r\n    var map = new Map();\r\n    for (let j = 1; j < grid[0].length; j += 2) {\r\n      if (grid[i][j].id === 0) {\r\n        grid[i][j].id = idCounter;\r\n        idCounter++;\r\n      }\r\n    }\r\n\r\n    for (let j = 1; j < grid[0].length; j += 2) {\r\n      var currentCell = grid[i][j];\r\n      getNeighboringCells(currentCell, grid);\r\n      if (grid.length - 2 !== i) {\r\n        path.push(currentCell);\r\n        currentCell.isWall = false;\r\n      }\r\n      if (Math.random() < 0.5 && currentCell.neighbors[0] !== null) {\r\n        if (grid.length - 2 !== i) {\r\n          path.push(currentCell.neighbors[0][0]);\r\n          currentCell.neighbors[0][0].isWall = false;\r\n        }\r\n        currentCell.neighbors[0][1].id = currentCell.id;\r\n      }\r\n    }\r\n    for (let j = 1; j < grid[0].length; j += 2) {\r\n      var currentCell = grid[i][j];\r\n      map.set(currentCell, currentCell.id);\r\n    }\r\n    if (grid.length - 2 === i) {\r\n      for (let j = 1; j < grid[0].length; j += 2) {\r\n        var currentCell = grid[i][j];\r\n        path.push(currentCell);\r\n        currentCell.isWall = false;\r\n        if (currentCell.neighbors[0] !== null) {\r\n          path.push(currentCell.neighbors[0][0]);\r\n          currentCell.neighbors[0][0].isWall = false;\r\n          currentCell.neighbors[0][1].id = currentCell.id;\r\n        }\r\n      }\r\n      continue;\r\n    }\r\n    for (let j = 1; j < grid[0].length; j += 2) {\r\n      var currentCell = grid[i][j];\r\n      var counter = 0;\r\n      map.forEach((value, key) => {\r\n        if (value === currentCell.id) {\r\n          counter++;\r\n        }\r\n      });\r\n      if (counter === 1) {\r\n        path.push(currentCell.neighbors[1][0]);\r\n        currentCell.neighbors[1][0].isWall = false;\r\n      } else if (counter > 1) {\r\n        if (Math.random() > 0.5) {\r\n          map.forEach((value, key) => {\r\n            if (value === currentCell.id) {\r\n              map.delete(key);\r\n            }\r\n          });\r\n          path.push(currentCell.neighbors[1][0]);\r\n          currentCell.neighbors[1][0].isWall = false;\r\n        } else {\r\n          map.forEach((value, key) => {\r\n            if (key === currentCell) {\r\n              map.delete(key);\r\n            }\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  clearInfinityVariables(grid);\r\n  window.gridComponent.setState({ grid: grid });\r\n  visualizeOnWalledGrid(grid, path);\r\n}\r\n\r\nfunction getNeighboringCells(cell, grid) {\r\n  //pair[neighboringWall, neighbor]\r\n  var { col, row } = cell;  \r\n  if (col < grid[0].length - 2) {\r\n    //Right\r\n    let neighbor = grid[row][col + 1];\r\n    cell.neighbors.push([neighbor, grid[row][col + 2]]);\r\n  } else {\r\n    cell.neighbors.push(null);\r\n  }\r\n  if (row < grid.length - 2) {\r\n    //Down\r\n    let neighbor = grid[row + 1][col];\r\n    cell.neighbors.push([neighbor, grid[row + 2][col]]);\r\n  } else {\r\n    cell.neighbors.push(null);\r\n  }\r\n}\r\n","import { visualizeCell } from \"../methods\";\r\nimport { clearVisitedCells } from \"../cleaning\";\r\n\r\nexport function animateSlow(visitedCells, cellsInOrder) {\r\n  for (let i = 0; i <= visitedCells.length; i++) {\r\n    const cell = visitedCells[i];\r\n    if (i === visitedCells.length) {\r\n      setTimeout(() => {\r\n        animatePathSlow(cellsInOrder);\r\n      }, 10 * i);\r\n      return;\r\n    }\r\n    setTimeout(() => {\r\n      if (cell.start && window.gridComponent.state.previousVisualization) {\r\n        visualizeCell(\"num\", \"num num-start\", cell);\r\n      }\r\n      if (cell.end && window.gridComponent.state.previousVisualization) {\r\n        visualizeCell(\"num\", \"num num-end\", cell);\r\n      }\r\n      if (!cell.isWall) {\r\n        if (!cell.start && !cell.end) {\r\n          visualizeCell(\"cell\", \"cell cell-visited-animated\", cell);\r\n          if (window.gridComponent.state.previousVisualization) {\r\n            visualizeCell(\"num\", \"num num-visited\", cell);\r\n          }\r\n        }\r\n      }\r\n    }, 10 * i);\r\n  }\r\n}\r\n\r\nfunction animatePathSlow(cellsInOrder) {\r\n  for (let i = 0; i <= cellsInOrder.length; i++) {\r\n    setTimeout(() => {\r\n      if (i === cellsInOrder.length) {\r\n        window.gridComponent.setState({ status: \"finished\" });\r\n        return;\r\n      }\r\n      const cell = cellsInOrder[i];\r\n      if (!cell.start && !cell.end) {\r\n        visualizeCell(\"cell\", \"cell cell-path-animated\", cell);\r\n        if (window.gridComponent.state.previousVisualization) {\r\n          visualizeCell(\"num\", \"num num-path\", cell);\r\n        }\r\n      }\r\n    }, 20 * i);\r\n  }\r\n}\r\n\r\nexport function animateFast(visitedCells, cellsInOrder) {\r\n  for (let i = 0; i <= visitedCells.length - 1; i++) {\r\n    const cell = visitedCells[i];\r\n\r\n    if (cell.start && window.gridComponent.state.previousVisualization) {\r\n      visualizeCell(\"num\", \"num num-start\", cell);\r\n    } else if (cell.end) {\r\n      if (window.gridComponent.state.previousVisualization) {\r\n        visualizeCell(\"num\", \"num num-end\", cell);\r\n      }\r\n      animatePathFast(cellsInOrder);\r\n    } else if (!cell.isWall) {\r\n      if (!cell.start && !cell.end) {\r\n        visualizeCell(\"cell\", \"cell cell-visited\", cell);\r\n        if (window.gridComponent.state.previousVisualization) {\r\n          visualizeCell(\"num\", \"num num-visited\", cell);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction animatePathFast(cellsInOrder) {\r\n  for (let i = 0; i < cellsInOrder.length; i++) {\r\n    const cell = cellsInOrder[i];\r\n    if (!cell.start && !cell.end) {\r\n      visualizeCell(\"cell\", \"cell cell-path\", cell);\r\n      if (window.gridComponent.state.previousVisualization) {\r\n        visualizeCell(\"num\", \"num num-path\", cell);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function animateAstarSlow(allSet, cellsInOrder) {\r\n  for (let i = 0; i <= allSet.length; i++) {\r\n    if (i === allSet.length) {\r\n      setTimeout(() => {\r\n        animatePathSlow(cellsInOrder);\r\n      }, 10 * i);\r\n      return;\r\n    }\r\n    setTimeout(() => {\r\n      clearVisitedCells();\r\n      var openSet = allSet[i][0];\r\n      var closedSet = allSet[i][1];\r\n\r\n      for (let j = 0; j < closedSet.length; j++) {\r\n        if (!closedSet[j].start && !closedSet[j].end) {\r\n          visualizeCell(\"cell\", \"cell cell-previous\", closedSet[j]);\r\n        }\r\n      }\r\n      for (let k = 0; k < openSet.length; k++) {\r\n        if (!openSet[k].start && !openSet[k].end) {\r\n          visualizeCell(\"cell\", \"cell cell-current\", openSet[k]);\r\n        }\r\n      }\r\n      if (\r\n        i < allSet.length - 1 &&\r\n        !closedSet[closedSet.length - 1].start &&\r\n        !closedSet[closedSet.length - 1].end\r\n      ) {\r\n        visualizeCell(\r\n          \"cell\",\r\n          \"cell cell-activepath\",\r\n          closedSet[closedSet.length - 1]\r\n        );\r\n      }\r\n    }, 10 * i);\r\n  }\r\n}\r\n\r\nexport function animateAstarFast(allSet, openSet, cellsInOrder) {\r\n  clearVisitedCells();\r\n  for (let k = 0; k < allSet.length; k++) {\r\n    if (!allSet[k].start && !allSet[k].end) {\r\n      visualizeCell(\"cell\", \"cell cell-previous\", allSet[k]);\r\n    }\r\n  }\r\n  for (let k = 0; k < openSet.length; k++) {\r\n    if (!openSet[k].start && !openSet[k].end) {\r\n      visualizeCell(\"cell\", \"cell cell-current\", openSet[k]);\r\n    }\r\n  }\r\n  animatePathFast(cellsInOrder);\r\n}","import { animateFast, animateSlow } from \"./animations\";\r\nimport { getCellsInOrder } from \"../../Algorithms/methods\";\r\nimport { clearVisitedCells } from \"../../Algorithms/cleaning\";\r\nvar id = 0;\r\nexport function dijkstra(grid, startCell, endCell, isDiagonalOn, speed) {\r\n  const unvisitedCells = [];\r\n  const visitedCells = [];\r\n  var direction = \"START\";\r\n  var previousRow = startCell.row;\r\n  startCell.distance = 0;\r\n\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      unvisitedCells.push(cell);\r\n    }\r\n  }\r\n\r\n  while (!!unvisitedCells.length) {\r\n    unvisitedCells.sort((cell1, cell2) => cell1.id - cell2.id);\r\n    unvisitedCells.sort((cell1, cell2) => cell1.distance - cell2.distance);\r\n\r\n    const nextCell = unvisitedCells.shift();\r\n    if (direction !== \"START\") {\r\n      if (nextCell.row < previousRow) {\r\n        direction = \"UP\";\r\n      } else {\r\n        direction = \"DOWN\";\r\n      }\r\n    }\r\n\r\n    if (nextCell.isWall && !nextCell.start && !nextCell.end) continue;\r\n\r\n    if (nextCell.distance === Infinity) {\r\n      DoAnimation(visitedCells, endCell, speed);\r\n      return;\r\n    }\r\n    nextCell.visited = true;\r\n    visitedCells.push(nextCell);\r\n    if (nextCell === endCell) {\r\n      unvisitedCells.sort((cell1, cell2) => cell1.id - cell2.id);\r\n      DoAnimation(visitedCells, endCell, speed);\r\n      return;\r\n    }\r\n\r\n    getUnvisitedNeighbors(nextCell, grid, direction, isDiagonalOn);\r\n    if (direction !== \"START\") {\r\n      previousRow = nextCell.row;\r\n    }\r\n    direction = \"CHANGED\";\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(cell, grid, direction, isDiagonalOn) {\r\n  const neighbors = [];\r\n  var { col, row } = cell;\r\n\r\n  if (direction === \"DOWN\" || direction === \"START\") {\r\n    Up(row, col, grid, neighbors);\r\n    Right(row, col, grid, neighbors);\r\n    Down(row, col, grid, neighbors);\r\n    Left(row, col, grid, neighbors);\r\n    if (isDiagonalOn) {\r\n      UpRight(row, col, grid, neighbors);\r\n      RightDown(row, col, grid, neighbors);\r\n      DownLeft(row, col, grid, neighbors);\r\n      LeftUp(row, col, grid, neighbors);\r\n    }\r\n  } else if (direction === \"UP\") {\r\n    Down(row, col, grid, neighbors);\r\n    Left(row, col, grid, neighbors);\r\n    Up(row, col, grid, neighbors);\r\n    Right(row, col, grid, neighbors);\r\n    if (isDiagonalOn) {\r\n      DownLeft(row, col, grid, neighbors);\r\n      LeftUp(row, col, grid, neighbors);\r\n      UpRight(row, col, grid, neighbors);\r\n      RightDown(row, col, grid, neighbors);\r\n    }\r\n  }\r\n\r\n  for (const neighbor of neighbors) {\r\n    neighbor.distance = cell.distance + 1;\r\n    neighbor.previous = cell;\r\n    neighbor.id = id;\r\n    id++;\r\n  }\r\n}\r\n\r\nfunction Up(row, col, grid, neighbors) {\r\n  if (row > 0) {\r\n    var cell = grid[row - 1][col];\r\n    if (!cell.visited && cell.previous === null) {\r\n      neighbors.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\nfunction Right(row, col, grid, neighbors) {\r\n  if (col < grid[0].length - 1) {\r\n    let cell = grid[row][col + 1];\r\n    if (!cell.visited && cell.previous === null) {\r\n      neighbors.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\nfunction Down(row, col, grid, neighbors) {\r\n  if (row < grid.length - 1) {\r\n    let cell = grid[row + 1][col];\r\n    if (!cell.visited && cell.previous === null) {\r\n      neighbors.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\nfunction Left(row, col, grid, neighbors) {\r\n  if (col > 0) {\r\n    let cell = grid[row][col - 1];\r\n    if (!cell.visited && cell.previous === null) {\r\n      neighbors.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\nfunction UpRight(row, col, grid, neighbors) {\r\n  if (row > 0 && col < grid[0].length - 1) {\r\n    let cell = grid[row - 1][col + 1];\r\n    if (grid[row - 1][col].isWall && grid[row][col + 1].isWall) {\r\n      return;\r\n    }\r\n    if (!cell.visited && cell.previous === null) {\r\n      neighbors.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\nfunction RightDown(row, col, grid, neighbors) {\r\n  if (col < grid[0].length - 1 && row < grid.length - 1) {\r\n    let cell = grid[row + 1][col + 1];\r\n    if (grid[row + 1][col].isWall && grid[row][col + 1].isWall) {\r\n      return;\r\n    }\r\n    if (!cell.visited && cell.previous === null) {\r\n      neighbors.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\nfunction DownLeft(row, col, grid, neighbors) {\r\n  if (row < grid.length - 1 && col > 0) {\r\n    let cell = grid[row + 1][col - 1];\r\n    if (grid[row + 1][col].isWall && grid[row][col - 1].isWall) {\r\n      return;\r\n    }\r\n    if (!cell.visited && cell.previous === null) {\r\n      neighbors.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\nfunction LeftUp(row, col, grid, neighbors) {\r\n  if (col > 0 && row > 0) {\r\n    let cell = grid[row - 1][col - 1];\r\n    if (grid[row][col - 1].isWall && grid[row - 1][col].isWall) {\r\n      return;\r\n    }\r\n    if (!cell.visited && cell.previous === null) {\r\n      neighbors.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\nfunction DoAnimation(visitedCells, endCell, speed) {\r\n  const cellsInOrder = getCellsInOrder(endCell);\r\n  if (speed === \"slow\") {\r\n    if (window.gridComponent.state.status === \"finished\") {\r\n      clearVisitedCells();\r\n    }\r\n    window.gridComponent.setState({ status: \"running\" });\r\n\r\n    animateSlow(visitedCells, cellsInOrder);\r\n  } else if (speed === \"fast\") {\r\n    animateFast(visitedCells, cellsInOrder);\r\n  }\r\n}\r\n","import {\r\n  animateAstarSlow,\r\n  animateAstarFast,\r\n} from \"./animations\";\r\nimport { getCellsInOrder } from \"../../Algorithms/methods\";\r\nimport { clearVisitedCells } from \"../../Algorithms/cleaning\";\r\n\r\nexport function astar(\r\n  grid,\r\n  startCell,\r\n  endCell,\r\n  isDiagonalOn,\r\n  optimized,\r\n  speed\r\n) {\r\n  findNeighbors(grid, isDiagonalOn);\r\n  const openSet = [];\r\n  const cameFrom = [];\r\n  var allSet = [];\r\n  openSet.push(startCell);\r\n  startCell.g = 0;\r\n  startCell.f = heuristic(startCell, endCell, isDiagonalOn, optimized);\r\n\r\n  while (!!openSet.length) {\r\n    var current = 0;\r\n    for (let j = 0; j < openSet.length; j++) {\r\n      if (openSet[j].f < openSet[current].f) {\r\n        current = j;\r\n      }\r\n    }\r\n    var currentCell = openSet[current];    \r\n    if (currentCell === endCell) {\r\n      console.log(endCell.end);\r\n      DoAnimation(allSet, openSet, endCell, speed);\r\n      return;\r\n    }\r\n    eliminateFromSet(openSet, currentCell);\r\n    var neighbors = currentCell.neighbors;\r\n    for (let k = 0; k < neighbors.length; k++) {\r\n      var neighbor = neighbors[k];\r\n      if (neighbor.isWall && !neighbor.start && !neighbor.end) {\r\n        continue;\r\n      }\r\n      var tentative_gScore =\r\n        currentCell.g + dScore(neighbor, currentCell, optimized);\r\n      if (tentative_gScore < neighbor.g) {\r\n        cameFrom.push(neighbor);\r\n        neighbor.g = tentative_gScore;\r\n        neighbor.h = heuristic(neighbor, endCell, isDiagonalOn, optimized);\r\n        neighbor.f = neighbor.g + neighbor.h;\r\n        neighbor.previous = currentCell;\r\n        if (!openSet.includes(neighbor)) {\r\n          openSet.push(neighbor);\r\n          if (speed === \"slow\") {\r\n            allSet.push([openSet.slice(0), cameFrom.slice(0)]);\r\n          } else if (speed === \"fast\") {\r\n            allSet.push(neighbor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  DoAnimation(allSet, openSet, endCell, speed);\r\n}\r\nfunction dScore(cell1, cell2, optimized) {\r\n  if (optimized) {\r\n    return cell1.row - cell2.row === 0 || cell1.col - cell2.col === 0\r\n      ? 1\r\n      : Math.SQRT2;\r\n  } else {\r\n    return 1;\r\n  }\r\n}\r\n\r\nfunction heuristic(cell1, cell2, isDiagonalOn, optimized) {\r\n  if (isDiagonalOn || !optimized) {\r\n    return Math.abs(cell1.row - cell2.row) + Math.abs(cell1.col - cell2.col);\r\n  } else {\r\n    if (optimized) {\r\n      return Math.sqrt(\r\n        (cell1.row - cell2.row) * (cell1.row - cell2.row) +\r\n          (cell1.col - cell2.col) * (cell1.col - cell2.col)\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction findNeighbors(grid, isDiagonalOn) {\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.neighbors = [];\r\n      if (cell.row > 0) {\r\n        //UP\r\n        cell.neighbors.push(grid[cell.row - 1][cell.col]);\r\n      }\r\n      if (cell.col < grid[0].length - 1) {\r\n        //RIGHT\r\n        cell.neighbors.push(grid[cell.row][cell.col + 1]);\r\n      }\r\n\r\n      if (cell.row < grid.length - 1) {\r\n        //DOWN\r\n        cell.neighbors.push(grid[cell.row + 1][cell.col]);\r\n      }\r\n\r\n      if (cell.col > 0) {\r\n        //LEFT\r\n        cell.neighbors.push(grid[cell.row][cell.col - 1]);\r\n      }\r\n      if (isDiagonalOn) {\r\n        if (cell.row > 0 && cell.col < grid[0].length - 1) {\r\n          //UPRIGHT\r\n          if (\r\n            !grid[cell.row - 1][cell.col].isWall ||\r\n            !grid[cell.row][cell.col + 1].isWall\r\n          ) {\r\n            cell.neighbors.push(grid[cell.row - 1][cell.col + 1]);\r\n          }\r\n        }\r\n        if (cell.col < grid[0].length - 1 && cell.row < grid.length - 1) {\r\n          //RIGHTDOWN\r\n          if (\r\n            !grid[cell.row + 1][cell.col].isWall ||\r\n            !grid[cell.row][cell.col + 1].isWall\r\n          ) {\r\n            cell.neighbors.push(grid[cell.row + 1][cell.col + 1]);\r\n          }\r\n        }\r\n        if (cell.row < grid.length - 1 && cell.col > 0) {\r\n          //DOWNLEFT\r\n          if (\r\n            !grid[cell.row + 1][cell.col].isWall ||\r\n            !grid[cell.row][cell.col - 1].isWall\r\n          ) {\r\n            cell.neighbors.push(grid[cell.row + 1][cell.col - 1]);\r\n          }\r\n        }\r\n        if (cell.col > 0 && cell.row > 0) {\r\n          //LEFTUP\r\n          if (\r\n            !grid[cell.row][cell.col - 1].isWall ||\r\n            !grid[cell.row - 1][cell.col].isWall\r\n          ) {\r\n            cell.neighbors.push(grid[cell.row - 1][cell.col - 1]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction eliminateFromSet(set, cell) {\r\n  for (let i = set.length - 1; i >= 0; i--) {\r\n    if (set[i] === cell) {\r\n      set.splice(i, 1);\r\n    }\r\n  }\r\n}\r\n\r\nfunction DoAnimation(allSet, openSet, endCell, speed) {\r\n  const cellsInOrder = getCellsInOrder(endCell);\r\n  if (speed === \"slow\") {\r\n    if (window.gridComponent.state.status === \"finished\") {\r\n      clearVisitedCells();\r\n    }\r\n    window.gridComponent.setState({ status: \"running\" });\r\n\r\n    animateAstarSlow(allSet, cellsInOrder);\r\n  } else if (speed === \"fast\") {\r\n    animateAstarFast(allSet, openSet, cellsInOrder);\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Cell from \"../Cell\";\r\nimport \"./index.css\";\r\nimport { createGrid, placeWall } from \"../Algorithms/methods\";\r\nimport { clearVisitedCells, clearWithStatus } from \"../Algorithms/cleaning\";\r\nimport { getRandomMazedGrid } from \"../Algorithms/mazes/default\";\r\nimport { primMaze } from \"../Algorithms/mazes/prim\";\r\nimport { iterativeMaze } from \"../Algorithms/mazes/iterativeDF\";\r\nimport { recursiveMaze } from \"../Algorithms/mazes/recursiveDF\";\r\nimport { aldousBroderMaze } from \"../Algorithms/mazes/aldousBroder\";\r\nimport { kruskalMaze } from \"../Algorithms/mazes/kruskal\";\r\nimport { wilsonMaze } from \"../Algorithms/mazes/wilson\";\r\nimport { recursiveDivision } from \"../Algorithms/mazes/recursiveDivision\";\r\nimport { basicHorizontal } from \"../Algorithms/mazes/basicHorizontal\";\r\nimport { basicVertical } from \"../Algorithms/mazes/basicVertical\";\r\nimport { binaryTreeAlg } from \"../Algorithms/mazes/binaryTree\";\r\nimport { ellerMaze } from \"../Algorithms/mazes/eller\";\r\nimport { dijkstra } from \"../Algorithms/searchers/dijsktra\";\r\nimport { astar } from \"../Algorithms/searchers/astar\";\r\n\r\nclass Grid extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: createGrid(props),\r\n      isMouseDown: false,\r\n      isStartOn: false,\r\n      isEndOn: false,\r\n      startRow: props.startR,\r\n      startCol: props.startC,\r\n      endRow: props.endR,\r\n      endCol: props.endC,\r\n      status: \"pending\",\r\n      currentAlg: \"dijkstra\",\r\n      currentMaze: \"default\",\r\n      previousVisualization: false,\r\n      diagonalVisualization: false,\r\n      optimizedVisualization: true,\r\n    };\r\n    this.handleAlgoChange = this.handleAlgoChange.bind(this);\r\n    this.handleButtonChange = this.handleButtonChange.bind(this);\r\n    this.handleMazeChange = this.handleMazeChange.bind(this);\r\n    window.gridComponent = this;\r\n  }\r\n\r\n  handleAlgoChange(event) {\r\n    this.setState({ currentAlg: event.target.value });\r\n  }\r\n  handleButtonChange(event) {\r\n    if (event.target.name === \"distance\") {\r\n      this.setState(\r\n        { previousVisualization: !this.state.previousVisualization },\r\n        () => {\r\n          if (this.state.status === \"finished\") {\r\n            clearVisitedCells();\r\n            if (this.state.currentAlg === \"dijkstra\") {\r\n              this.doAlgorithm(\"fast\");\r\n            }\r\n          }\r\n        }\r\n      );\r\n    } else if (event.target.name === \"diagonal\") {\r\n      this.setState(\r\n        { diagonalVisualization: !this.state.diagonalVisualization },\r\n        () => {\r\n          if (this.state.status === \"finished\") {\r\n            clearVisitedCells();\r\n            this.doAlgorithm(\"fast\");\r\n          }\r\n        }\r\n      );\r\n    } else if (event.target.name === \"optimized\") {\r\n      this.setState(\r\n        { optimizedVisualization: !this.state.optimizedVisualization },\r\n        () => {\r\n          if (this.state.status === \"finished\") {\r\n            clearVisitedCells();\r\n            this.doAlgorithm(\"fast\");\r\n          }\r\n        }\r\n      );\r\n    }\r\n  }\r\n  handleMazeChange(event) {\r\n    if (event.target.value === \"random\") getRandomMazedGrid(this.state.grid);\r\n    else if (event.target.value === \"prim\") primMaze(this.state.grid);\r\n    else if (event.target.value === \"iterative\") iterativeMaze(this.state.grid);\r\n    else if (event.target.value === \"recursive\") recursiveMaze(this.state.grid);\r\n    else if (event.target.value === \"aldousBroder\")\r\n      aldousBroderMaze(this.state.grid);\r\n    else if (event.target.value === \"kruskal\") kruskalMaze(this.state.grid);\r\n    else if (event.target.value === \"wilson\") wilsonMaze(this.state.grid);\r\n    else if (event.target.value === \"recursiveDivision\")\r\n      recursiveDivision(this.state.grid);\r\n    else if (event.target.value === \"basicHorizontal\")\r\n      basicHorizontal(this.state.grid);\r\n    else if (event.target.value === \"basicVertical\")\r\n      basicVertical(this.state.grid);\r\n    else if (event.target.value === \"eller\") ellerMaze(this.state.grid);\r\n    else if (event.target.value === \"binaryTreeNW\")\r\n      binaryTreeAlg(this.state.grid, \"NorthWest\");\r\n    else if (event.target.value === \"binaryTreeNE\")\r\n      binaryTreeAlg(this.state.grid, \"NorthEast\");\r\n    else if (event.target.value === \"binaryTreeSW\")\r\n      binaryTreeAlg(this.state.grid, \"SouthWest\");\r\n    else if (event.target.value === \"binaryTreeSE\")\r\n      binaryTreeAlg(this.state.grid, \"SouthEast\");\r\n  }\r\n\r\n  onMouseDown = (cell) => {\r\n    if (this.state.status === \"running\") {\r\n      return;\r\n    }\r\n    this.setState({ isMouseDown: true });\r\n    if (cell.start) {\r\n      this.setState({ isStartOn: true });\r\n      return;\r\n    }\r\n    if (cell.end) {\r\n      this.setState({ isEndOn: true });\r\n      return;\r\n    }\r\n    placeWall(cell);\r\n  };\r\n\r\n  onMouseEnter = (cell) => {\r\n    if (this.state.isMouseDown) {\r\n      if (cell.start || cell.end) {\r\n        return;\r\n      }\r\n      if (this.state.isStartOn) {\r\n        let newGrid = this.state.grid.slice();\r\n        newGrid[this.state.startRow][this.state.startCol].start = false;\r\n        newGrid[cell.row][cell.col].start = true;\r\n        this.setState(\r\n          {\r\n            grid: newGrid,\r\n            startRow: cell.row,\r\n            startCol: cell.col,\r\n          },\r\n          () => {\r\n            if (this.state.status === \"finished\") {\r\n              clearVisitedCells();\r\n              this.doAlgorithm(\"fast\");\r\n            } else {\r\n              clearWithStatus(\"path\");\r\n            }\r\n          }\r\n        );\r\n        return;\r\n      } else if (this.state.isEndOn) {\r\n        let newGrid = this.state.grid.slice();\r\n        newGrid[this.state.endRow][this.state.endCol].end = false;\r\n        newGrid[cell.row][cell.col].end = true;\r\n        this.setState(\r\n          {\r\n            grid: newGrid,\r\n            endRow: cell.row,\r\n            endCol: cell.col,\r\n          },\r\n          () => {\r\n            if (this.state.status === \"finished\") {\r\n              clearVisitedCells();\r\n              this.doAlgorithm(\"fast\");\r\n            } else {\r\n              clearWithStatus(\"path\");\r\n            }\r\n          }\r\n        );\r\n        return;\r\n      }\r\n      placeWall(cell);\r\n    }\r\n  };\r\n  onMouseUp = () => {\r\n    this.setState({ isMouseDown: false, isStartOn: false, isEndOn: false });\r\n  };\r\n\r\n  doAlgorithm = (speed) => {\r\n    let { grid } = this.state;\r\n    const startCell = grid[this.state.startRow][this.state.startCol];\r\n    const endCell = grid[this.state.endRow][this.state.endCol];\r\n\r\n    if (this.state.currentAlg === \"dijkstra\") {\r\n      dijkstra(\r\n        grid,\r\n        startCell,\r\n        endCell,\r\n        this.state.diagonalVisualization,\r\n        speed\r\n      );\r\n    } else if (this.state.currentAlg === \"astar\") {\r\n      astar(\r\n        grid,\r\n        startCell,\r\n        endCell,\r\n        this.state.diagonalVisualization,\r\n        this.state.optimizedVisualization,\r\n        speed\r\n      );\r\n    }\r\n  };\r\n\r\n  render() {\r\n    let grid = this.state.grid.map((row, index) => {\r\n      return (\r\n        <div key={index} className=\"row\">\r\n          {row.map((cell, cellIndex) => {\r\n            return (\r\n              <Cell\r\n                key={cellIndex}\r\n                data={cell}\r\n                onMouseDown={this.onMouseDown}\r\n                onMouseEnter={this.onMouseEnter}\r\n                onMouseUp={this.onMouseUp}\r\n              />\r\n            );\r\n          })}\r\n        </div>\r\n      );\r\n    });\r\n    return (\r\n      <div>\r\n        <div className=\"grid\" onMouseLeave={this.onMouseUp}>\r\n          {grid}\r\n        </div>\r\n        <select\r\n          value={this.state.currentAlg}\r\n          onChange={this.handleAlgoChange}\r\n          disabled={this.state.status === \"running\"}\r\n        >\r\n          <option value=\"dijkstra\">Dijkstra</option>\r\n          <option value=\"astar\">A* Search</option>\r\n        </select>\r\n        <button\r\n          disabled={this.state.status === \"running\"}\r\n          onClick={() => this.doAlgorithm(\"slow\")}\r\n        >\r\n          Start\r\n        </button>\r\n        <button\r\n          disabled={this.state.status === \"running\"}\r\n          onClick={() => {\r\n            clearWithStatus(\"path\");\r\n          }}\r\n        >\r\n          Clear path\r\n        </button>\r\n        <button\r\n          disabled={this.state.status === \"running\"}\r\n          onClick={() => {\r\n            clearWithStatus(\"grid\");\r\n          }}\r\n        >\r\n          Clear grid\r\n        </button>\r\n        Distance\r\n        <label className=\"switch\">\r\n          <input\r\n            disabled={\r\n              this.state.status === \"running\" ||\r\n              this.state.currentAlg === \"astar\"\r\n            }\r\n            type=\"checkbox\"\r\n            defaultChecked={this.state.previousVisualization}\r\n            onChange={this.handleButtonChange}\r\n            name=\"distance\"\r\n          ></input>\r\n          <span className=\"slider round\"></span>\r\n        </label>\r\n        Diagonal\r\n        <label className=\"switch\">\r\n          <input\r\n            disabled={this.state.status === \"running\"}\r\n            type=\"checkbox\"\r\n            defaultChecked={this.state.diagonalVisualization}\r\n            onChange={this.handleButtonChange}\r\n            name=\"diagonal\"\r\n          ></input>\r\n          <span className=\"slider round\"></span>\r\n        </label>\r\n        Optimized\r\n        <label className=\"switch\">\r\n          <input\r\n            disabled={\r\n              this.state.status === \"running\" ||\r\n              this.state.currentAlg === \"dijkstra\"\r\n            }\r\n            type=\"checkbox\"\r\n            defaultChecked={this.state.optimizedVisualization}\r\n            onChange={this.handleButtonChange}\r\n            name=\"optimized\"\r\n          ></input>\r\n          <span className=\"slider round\"></span>\r\n        </label>\r\n        <select\r\n          value={this.state.currentMaze}\r\n          onChange={this.handleMazeChange}\r\n          disabled={this.state.status === \"running\"}\r\n        >\r\n          <option value=\"default\" disabled hidden>\r\n            Mazes\r\n          </option>\r\n          <optgroup label=\"Patterns\">\r\n            <option value=\"random\">Random</option>\r\n            <option value=\"basicHorizontal\">Basic Horizontal</option>\r\n            <option value=\"basicVertical\">Basic Vertical</option>\r\n          </optgroup>\r\n          <optgroup label=\"Algorithms\">\r\n            <option value=\"prim\">Prim</option>\r\n            <option value=\"iterative\">Iterative Depth-first</option>\r\n            <option value=\"recursive\">Recursive Depth-first</option>\r\n            <option value=\"aldousBroder\">Aldous-Broder</option>\r\n            <option value=\"kruskal\">Kruskal</option>\r\n            <option value=\"wilson\">Wilson</option>\r\n            <option value=\"recursiveDivision\">Recursive Division</option>\r\n            <option value=\"eller\">Eller</option>\r\n          </optgroup>\r\n          <optgroup label=\"&nbsp;&nbsp;&nbsp;Binary Tree Algorithm\">\r\n            <option value=\"binaryTreeSE\">&nbsp;&nbsp;&nbsp;South-East</option>\r\n            <option value=\"binaryTreeSW\">&nbsp;&nbsp;&nbsp;South-West</option>\r\n            <option value=\"binaryTreeNE\">&nbsp;&nbsp;&nbsp;North-East</option>\r\n            <option value=\"binaryTreeNW\">&nbsp;&nbsp;&nbsp;North-West</option>\r\n          </optgroup>\r\n        </select>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Grid;\r\n","import React, { Component } from \"react\";\r\nimport Grid from \"../../path-finder/src/Grid\";\r\n\r\nclass App extends Component {\r\n  constructor(props) {\r\n    super();\r\n    this.state = {\r\n      rows: this.getSize(\"row\"),\r\n      columns: this.getSize(\"col\"),\r\n      startR: this.getPosition(\"row\"),\r\n      startC: this.getPosition(\"startCol\"),\r\n      endR: this.getPosition(\"row\"),\r\n      endC: this.getPosition(\"endCol\"),\r\n    };\r\n  }\r\n\r\n  getPosition = (parameter) => {\r\n    let position = null;\r\n    if (parameter === \"row\") {\r\n      position = Math.floor(this.getSize(\"row\") / 2);\r\n    } else if (parameter === \"startCol\") {\r\n      position = Math.floor(this.getSize(\"col\") / 5);\r\n    } else if (parameter === \"endCol\") {\r\n      let x = this.getSize(\"col\");\r\n      let margin = Math.ceil(x / 5);\r\n      position = x - margin;\r\n    }\r\n    return position % 2 === 0 ? position + 1 : position;\r\n    // return position;\r\n  };\r\n\r\n  getSize = (type) => {\r\n    let size = null;\r\n    if (type === \"row\") {\r\n      size = (window.innerHeight / 30).toFixed(0) - 5;\r\n      if (size < 10) {\r\n        return 9;\r\n      }\r\n    } else if (type === \"col\") {\r\n      size = (window.innerWidth / 30).toFixed(0) - 5;\r\n      if (size < 10) {\r\n        return 9;\r\n      }\r\n    }\r\n    if (size % 2 === 0) {\r\n      size--;\r\n    }\r\n    return size;\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"App\">\r\n        <Grid\r\n          rows={this.state.rows}\r\n          columns={this.state.columns}\r\n          startR={this.state.startR}\r\n          startC={this.state.startC}\r\n          endR={this.state.endR}\r\n          endC={this.state.endC}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n}\r\nexport default App;\r\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}