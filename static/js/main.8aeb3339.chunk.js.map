{"version":3,"sources":["Cell/index.js","Algorithms/cleaning.js","Algorithms/methods.js","Algorithms/mazes/animations.js","Algorithms/mazes/default.js","Algorithms/mazes/prim.js","Algorithms/mazes/iterative.js","Algorithms/mazes/aldousBroder.js","Algorithms/searchers/animations.js","Algorithms/searchers/dijsktra.js","Algorithms/searchers/astar.js","Grid/index.js","App.js","index.js"],"names":["getColor","props","data","start","end","Cell","className","id","row","col","onMouseDown","e","preventDefault","onMouseEnter","onMouseUp","onContextMenu","distance","Infinity","clearWithStatus","type","clearVisitedCells","window","gridComponent","setState","grid","createGrid","startRow","startR","startCol","startC","endRow","endR","endCol","endC","state","cell","visualizeCell","clearBoard","status","newGrid","i","rows","j","columns","visited","previous","f","g","h","neighbors","isWall","clearInfinityVariables","push","getCellsInOrder","endCell","cells","unshift","placeWall","newCell","doAlgorithm","category","name","document","getElementById","visualizeOnWalledGrid","path","setTimeout","length","getRandomMazedGrid","numberOfCells","wallAmount","Math","floor","random","visualizeRandom","getNeighboringWalls","wallPairs","neighbor","takeRandomPair","position","pair","splice","takeLastCell","cellsWithUnvisitedNeighbors","getNeighboringCells","neighboringUnvisitedPairs","aldousBroderMaze","originalGrid","JSON","parse","stringify","unvisitedCells","visualizationList","current","filter","item","visualizeABMaze","animatePathSlow","cellsInOrder","previousVisualization","animatePathFast","getUnvisitedNeighbors","direction","isDiagonalOn","Up","Right","Down","Left","UpRight","RightDown","DownLeft","LeftUp","DoAnimation","visitedCells","speed","animateSlow","animateFast","astar","startCell","optimized","findNeighbors","openSet","cameFrom","allSet","heuristic","currentCell","console","log","eliminateFromSet","k","tentative_gScore","dScore","includes","slice","cell1","cell2","SQRT2","abs","sqrt","set","closedSet","animateAstarSlow","animateAstarFast","Grid","isMouseDown","isStartOn","isEndOn","currentAlg","previousRow","sort","nextCell","shift","dijkstra","diagonalVisualization","optimizedVisualization","currentMaze","handleAlgoChange","bind","handleButtonChange","handleMazeChange","event","this","target","value","currentPair","primMaze","randomPair","iterativeMaze","map","index","key","cellIndex","onMouseLeave","onChange","disabled","onClick","defaultChecked","hidden","Component","App","getPosition","parameter","getSize","x","ceil","size","innerHeight","toFixed","innerWidth","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.8aeb3339.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./index.css\";\r\nfunction getColor(props) {\r\n  if (props.data.start) {\r\n    return \"cell-start\";\r\n  } else if (props.data.end) {\r\n    return \"cell-end\";\r\n  }else {\r\n    return \"\";\r\n  }\r\n}\r\n\r\nconst Cell = (props) => {\r\n  return (\r\n    <div\r\n      className={`cell ${getColor(props)}`}\r\n      id={`cell-${props.data.row}-${props.data.col}`}\r\n      onMouseDown={(e) => {\r\n        e.preventDefault();\r\n        props.onMouseDown(props.data);\r\n      }}\r\n      onMouseEnter={() => props.onMouseEnter(props.data)}\r\n      onMouseUp={() => props.onMouseUp(props.data)}\r\n      onContextMenu={(e) => {\r\n        e.preventDefault();\r\n      }}\r\n    >\r\n      <div\r\n        className={`num ${\"\"}`}\r\n        id={`num-${props.data.row}-${props.data.col}`}\r\n      >\r\n        {props.data.distance === Infinity ? \"\" : props.data.distance}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Cell;\r\n","import { visualizeCell, createGrid } from \"../Algorithms/methods\";\r\n\r\nexport function clearWithStatus(type) {\r\n  if (type === \"path\") {\r\n    clearVisitedCells();\r\n  } else if (type === \"grid\") {\r\n    clearBoard(window.gridComponent.props);\r\n  }\r\n  window.gridComponent.setState({ status: \"pending\" });\r\n}\r\n\r\nexport function clearVisitedCells() {\r\n  let newGrid = window.gridComponent.state.grid;\r\n  for (let i = 0; i < window.gridComponent.props.rows; i++) {\r\n    for (let j = 0; j < window.gridComponent.props.columns; j++) {\r\n      let cell = newGrid[i][j];\r\n      cell.visited = false;\r\n      cell.distance = Infinity;\r\n      cell.previous = null;\r\n      cell.f = Infinity;\r\n      cell.g = Infinity;\r\n      cell.h = Infinity;\r\n      cell.neighbors = [];\r\n\r\n      visualizeCell(\"num\", \"num\", cell);\r\n      if (!cell.isWall && !cell.end && !cell.start) {\r\n        visualizeCell(\"cell\", \"cell cell-empty\", cell);\r\n      }\r\n      if (cell.isWall && !cell.end && !cell.start) {\r\n        visualizeCell(\"cell\", \"cell cell-wall\", cell);\r\n      }\r\n    }\r\n  }\r\n  window.gridComponent.setState({ grid: newGrid });\r\n}\r\n\r\nexport function clearBoard(props) {\r\n  clearVisitedCells();\r\n  window.gridComponent.setState({\r\n    grid: createGrid(props),\r\n    startRow: props.startR,\r\n    startCol: props.startC,\r\n    endRow: props.endR,\r\n    endCol: props.endC,\r\n  });\r\n  for (const row of window.gridComponent.state.grid) {\r\n    for (const cell of row) {\r\n      if (!cell.end && !cell.start) {\r\n        visualizeCell(\"cell\", \"cell cell-empty\", cell);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function clearInfinityVariables(grid) {\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.distance = Infinity;\r\n      cell.f = Infinity;\r\n      cell.g = Infinity;\r\n      cell.h = Infinity;\r\n      cell.visited = false;\r\n    }\r\n  }\r\n  window.gridComponent.setState({ grid: grid });\r\n}\r\n","import { clearVisitedCells } from \"../Algorithms/cleaning\";\r\n\r\nexport function createGrid(props) {\r\n  let grid = [];\r\n\r\n  for (let i = 0; i < props.rows; i++) {\r\n    grid.push([]);\r\n    for (let j = 0; j < props.columns; j++) {\r\n      grid[i].push({\r\n        id: 0,\r\n        row: i,\r\n        col: j,\r\n        start: false,\r\n        end: false,\r\n        distance: Infinity,\r\n        visited: false,\r\n        isWall: false,\r\n        previous: null,\r\n        //TODO: ASTAR scenario (this variables shall be handled differently later)\r\n        f: Infinity,\r\n        g: Infinity,\r\n        h: Infinity,\r\n        neighbors: [],\r\n      });\r\n    }\r\n  }\r\n\r\n  grid[props.startR][props.startC].start = true;\r\n  grid[props.endR][props.endC].end = true;\r\n\r\n  return grid;\r\n}\r\n\r\nexport function getCellsInOrder(endCell) {\r\n  const cells = [];\r\n  let cell = endCell;\r\n  while (cell !== null) {\r\n    cells.unshift(cell);\r\n    cell = cell.previous;\r\n  }\r\n  return cells;\r\n}\r\n\r\nexport function placeWall(cell) {\r\n  let newCell = cell;\r\n  let newGrid = window.gridComponent.state.grid;\r\n  newCell.isWall = !newCell.isWall;\r\n  if (newCell.isWall) {\r\n    visualizeCell(\"cell\", \"cell cell-wall-animated\", cell);\r\n  } else {\r\n    visualizeCell(\"cell\", \"cell cell-empty\", cell);\r\n    \r\n  }\r\n\r\n  visualizeCell(\"num\", \"num\", newCell);\r\n  newCell.visited = false;\r\n\r\n  newGrid[cell.row][cell.col] = newCell;\r\n  window.gridComponent.setState({ grid: newGrid }, () => {\r\n    if (window.gridComponent.state.status === \"finished\") {\r\n      clearVisitedCells();\r\n      window.gridComponent.doAlgorithm(\"fast\");\r\n    }\r\n  });\r\n}\r\n\r\nexport function visualizeCell(category, name, cell) {\r\n  document.getElementById(\r\n    `${category}-${cell.row}-${cell.col}`\r\n  ).className = name;\r\n}\r\n","import { visualizeCell } from \"../methods\";\r\nexport function visualizeOnWalledGrid(grid, path) {\r\n  window.gridComponent.setState({ status: \"running\" });\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      if (!cell.end && !cell.start) {\r\n        visualizeCell(\"cell\", \"cell cell-wall\", cell);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i <= path.length; i++) {\r\n    setTimeout(() => {\r\n      if (i === path.length) {\r\n        window.gridComponent.setState({ status: \"pending\" });\r\n        return;\r\n      }\r\n      if (!path[i].end && !path[i].start) {\r\n        visualizeCell(\"cell\", \"cell cell-empty\", path[i]);\r\n      }\r\n    }, 8 * i);\r\n  }\r\n}\r\n\r\nexport function visualizeRandom(grid, path) {\r\n  window.gridComponent.setState({ status: \"running\" });\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      if (!cell.end && !cell.start) {\r\n        visualizeCell(\"cell\", \"cell cell-empty\", cell);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i <= path.length; i++) {\r\n    setTimeout(() => {\r\n      if (i === path.length) {\r\n        window.gridComponent.setState({ status: \"pending\" });\r\n        return;\r\n      }\r\n      if (!path[i].end && !path[i].start) {\r\n        visualizeCell(\"cell\", \"cell cell-wall\", path[i]);\r\n      }\r\n    }, 8 * i);\r\n  }\r\n}\r\n\r\nexport function visualizeABMaze(grid, path) {\r\n  window.gridComponent.setState({ status: \"running\" });\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      if (!cell.end && !cell.start) {\r\n        visualizeCell(\"cell\", \"cell cell-wall\", cell);\r\n      }\r\n    }\r\n  }\r\n  var previous = null;\r\n  for (let i = 0; i <= path.length; i++) {\r\n    setTimeout(() => {\r\n      if (i === path.length) {\r\n        window.gridComponent.setState({ status: \"pending\" });\r\n        visualizeCell(\"cell\", \"cell cell-empty\", path[path.length - 1]);\r\n        return;\r\n      }\r\n      if (previous !== null) {\r\n        if (previous.isWall) {\r\n          visualizeCell(\"cell\", \"cell cell-wall\", previous);\r\n        } else {\r\n          visualizeCell(\"cell\", \"cell cell-empty\", previous);\r\n        }\r\n      }\r\n      if (!path[i].end && !path[i].start) {\r\n        visualizeCell(\"cell\", \"cell cell-current\", path[i]);\r\n        previous = path[i];\r\n      }\r\n    }, 10 * i);\r\n  }\r\n}\r\n","import { clearVisitedCells } from \"../../Algorithms/cleaning\";\r\nimport { visualizeRandom } from \"../mazes/animations\";\r\n\r\nexport function getRandomMazedGrid(grid) {\r\n  clearVisitedCells();\r\n  var path = [];\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.isWall = false;\r\n    }\r\n  }\r\n  var numberOfCells = (grid.length - 1) * (grid[0].length - 1);\r\n\r\n  var wallAmount = Math.floor(numberOfCells * 0.4); //0.4 should be later replaced with the amount\r\n\r\n  for (let i = 0; i < wallAmount; i++) {\r\n    let row = Math.floor(Math.random() * (grid.length - 1));\r\n    let col = Math.floor(Math.random() * (grid[0].length - 1));\r\n\r\n    let cell = grid[row][col];\r\n    if (cell.start || cell.end || cell.isWall) {\r\n      i--;\r\n    } else {\r\n      cell.isWall = true;\r\n      path.push(cell);\r\n    }\r\n  }\r\n  window.gridComponent.setState({ grid: grid });\r\n  visualizeRandom(grid, path);\r\n}\r\n","import {\r\n  clearWithStatus,\r\n  clearInfinityVariables,\r\n} from \"../../Algorithms/cleaning\";\r\nimport { visualizeOnWalledGrid } from \"../mazes/animations\";\r\nexport function primMaze(originalGrid) {\r\n  clearWithStatus(\"path\");\r\n  var grid = JSON.parse(JSON.stringify(originalGrid));\r\n  var path = [];\r\n  const wallPairs = [];\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.isWall = true;\r\n    }\r\n  }\r\n  getNeighboringWalls(grid[1][1], grid, wallPairs);\r\n  while (!!wallPairs.length) {\r\n    var currentPair = takeRandomPair(wallPairs);\r\n    if (!currentPair[1].isWall) {\r\n      continue;\r\n    }\r\n    currentPair[0].isWall = false;\r\n    currentPair[1].isWall = false;\r\n    path.push(currentPair[0]);\r\n    path.push(currentPair[1]);\r\n    getNeighboringWalls(currentPair[1], grid, wallPairs);\r\n  }\r\n  clearInfinityVariables(grid);\r\n  visualizeOnWalledGrid(grid, path);\r\n}\r\n\r\nfunction getNeighboringWalls(cell, grid, wallPairs) {\r\n  var { col, row } = cell;\r\n  if (row > 1) {\r\n    //UP\r\n    var neighbor = grid[row - 1][col];\r\n    wallPairs.push([neighbor, grid[row - 2][col]]);\r\n  }\r\n  if (col < grid[0].length - 2) {\r\n    //Right\r\n    let neighbor = grid[row][col + 1];\r\n    wallPairs.push([neighbor, grid[row][col + 2]]);\r\n  }\r\n  if (row < grid.length - 2) {\r\n    //Down\r\n    let neighbor = grid[row + 1][col];\r\n    wallPairs.push([neighbor, grid[row + 2][col]]);\r\n  }\r\n  if (col > 1) {\r\n    //Left\r\n    let neighbor = grid[row][col - 1];\r\n    wallPairs.push([neighbor, grid[row][col - 2]]);\r\n  }\r\n}\r\n\r\nfunction takeRandomPair(wallPairs) {\r\n  var position = Math.floor(Math.random() * wallPairs.length);\r\n  var pair = wallPairs[position];\r\n  wallPairs.splice(position, 1);\r\n  return pair;\r\n}\r\n","import {\r\n  clearWithStatus,\r\n  clearInfinityVariables,\r\n} from \"../../Algorithms/cleaning\";\r\nimport { visualizeOnWalledGrid } from \"../mazes/animations\";\r\nexport function iterativeMaze(originalGrid) {\r\n  clearWithStatus(\"path\");\r\n  var path = [];\r\n  var grid = JSON.parse(JSON.stringify(originalGrid));\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.isWall = true;\r\n    }\r\n  }\r\n  var currentCell = grid[1][1];\r\n  currentCell.visited = true;\r\n  currentCell.isWall = false;\r\n  path.push(currentCell);\r\n  var cellsWithUnvisitedNeighbors = [];\r\n  cellsWithUnvisitedNeighbors.push(currentCell);\r\n\r\n  while (!!cellsWithUnvisitedNeighbors.length) {\r\n    currentCell = takeLastCell(cellsWithUnvisitedNeighbors);\r\n    var neighboringUnvisitedPairs = getNeighboringCells(currentCell, grid);\r\n    if (neighboringUnvisitedPairs.length > 0) {\r\n      cellsWithUnvisitedNeighbors.push(currentCell);\r\n      var randomPair =\r\n        neighboringUnvisitedPairs[\r\n          Math.floor(Math.random() * neighboringUnvisitedPairs.length)\r\n        ];\r\n      randomPair[0].isWall = false;\r\n      randomPair[1].isWall = false;\r\n      randomPair[1].visited = true;\r\n      path.push(randomPair[0]);\r\n      path.push(randomPair[1]);\r\n      cellsWithUnvisitedNeighbors.push(randomPair[1]);\r\n    }\r\n  }\r\n\r\n  clearInfinityVariables(grid);\r\n  window.gridComponent.setState({ grid: grid });\r\n  visualizeOnWalledGrid(grid, path);\r\n}\r\n\r\nfunction takeLastCell(cellsWithUnvisitedNeighbors) {\r\n  var position = cellsWithUnvisitedNeighbors.length - 1;\r\n  var cell = cellsWithUnvisitedNeighbors[position];\r\n  cellsWithUnvisitedNeighbors.splice(position, 1);\r\n  return cell;\r\n}\r\n\r\nfunction getNeighboringCells(cell, grid) {\r\n  var neighboringUnvisitedPairs = []; //pair[neighboringWall, neighbor]\r\n  var { col, row } = cell;\r\n  if (row > 1) {\r\n    //UP\r\n    var neighbor = grid[row - 1][col];\r\n    if (grid[row - 2][col].visited === false) {\r\n      neighboringUnvisitedPairs.push([neighbor, grid[row - 2][col]]);\r\n    }\r\n  }\r\n  if (col < grid[0].length - 2) {\r\n    //Right\r\n    let neighbor = grid[row][col + 1];\r\n    if (grid[row][col + 2].visited === false) {\r\n      neighboringUnvisitedPairs.push([neighbor, grid[row][col + 2]]);\r\n    }\r\n  }\r\n  if (row < grid.length - 2) {\r\n    //Down\r\n    let neighbor = grid[row + 1][col];\r\n    if (grid[row + 2][col].visited === false) {\r\n      neighboringUnvisitedPairs.push([neighbor, grid[row + 2][col]]);\r\n    }\r\n  }\r\n  if (col > 1) {\r\n    //Left\r\n    let neighbor = grid[row][col - 1];\r\n    if (grid[row][col - 2].visited === false) {\r\n      neighboringUnvisitedPairs.push([neighbor, grid[row][col - 2]]);\r\n    }\r\n  }\r\n\r\n  return neighboringUnvisitedPairs;\r\n}\r\n","import { visualizeABMaze } from \"../mazes/animations\";\r\nimport {\r\n  clearWithStatus,\r\n  clearInfinityVariables,\r\n} from \"../../Algorithms/cleaning\";\r\n\r\nexport function aldousBroderMaze(originalGrid) {\r\n  clearWithStatus(\"path\");\r\n  var grid = JSON.parse(JSON.stringify(originalGrid));\r\n  var unvisitedCells = [];\r\n  var visualizationList = [];\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.isWall = true;\r\n      if (cell.row % 2 === 1 && cell.col % 2 === 1) {\r\n        cell.id = unvisitedCells.length;\r\n        unvisitedCells.push(cell);\r\n        getNeighboringCells(cell, grid);\r\n      }\r\n    }\r\n  }\r\n\r\n  var current = unvisitedCells[0];\r\n  unvisitedCells.splice(0, 1);\r\n  current.visited = true;\r\n  current.isWall = false;\r\n\r\n  while (!!unvisitedCells.length) {\r\n    var neighbor =\r\n      current.neighbors[Math.floor(Math.random() * current.neighbors.length)];\r\n    visualizationList.push(neighbor[0]);\r\n    visualizationList.push(neighbor[1]);\r\n    if (!neighbor[1].visited) {\r\n      neighbor[0].isWall = false;\r\n      neighbor[1].isWall = false;\r\n      unvisitedCells = unvisitedCells.filter(\r\n        (item) => item.id !== neighbor[1].id\r\n      );\r\n      neighbor[1].visited = true;\r\n    }\r\n    current = neighbor[1];\r\n  }\r\n  clearInfinityVariables(grid);\r\n  window.gridComponent.setState({ grid: grid });\r\n  visualizeABMaze(grid, visualizationList);\r\n}\r\n\r\n/*function takeRandomCell(unvisitedCells) {\r\n  var position = Math.floor(Math.random() * unvisitedCells.length);\r\n  var cell = unvisitedCells[0];\r\n  unvisitedCells.splice(0, 1);\r\n  return cell;\r\n}*/\r\n\r\nfunction getNeighboringCells(cell, grid) {\r\n  //pair[neighboringWall, neighbor]\r\n  var { col, row } = cell;\r\n  if (row > 1) {\r\n    //UP\r\n    var neighbor = grid[row - 1][col];\r\n    cell.neighbors.push([neighbor, grid[row - 2][col]]);\r\n  }\r\n  if (col < grid[0].length - 2) {\r\n    //Right\r\n    let neighbor = grid[row][col + 1];\r\n    cell.neighbors.push([neighbor, grid[row][col + 2]]);\r\n  }\r\n  if (row < grid.length - 2) {\r\n    //Down\r\n    let neighbor = grid[row + 1][col];\r\n    cell.neighbors.push([neighbor, grid[row + 2][col]]);\r\n  }\r\n  if (col > 1) {\r\n    //Left\r\n    let neighbor = grid[row][col - 1];\r\n    cell.neighbors.push([neighbor, grid[row][col - 2]]);\r\n  }\r\n}\r\n","import { visualizeCell } from \"../methods\";\r\nimport { clearVisitedCells } from \"../cleaning\";\r\n\r\nexport function animateSlow(visitedCells, cellsInOrder) {\r\n  for (let i = 0; i <= visitedCells.length; i++) {\r\n    const cell = visitedCells[i];\r\n    if (i === visitedCells.length) {\r\n      setTimeout(() => {\r\n        animatePathSlow(cellsInOrder);\r\n      }, 10 * i);\r\n      return;\r\n    }\r\n    setTimeout(() => {\r\n      if (cell.start && window.gridComponent.state.previousVisualization) {\r\n        visualizeCell(\"num\", \"num num-start\", cell);\r\n      }\r\n      if (cell.end && window.gridComponent.state.previousVisualization) {\r\n        visualizeCell(\"num\", \"num num-end\", cell);\r\n      }\r\n      if (!cell.isWall) {\r\n        if (!cell.start && !cell.end) {\r\n          visualizeCell(\"cell\", \"cell cell-visited-animated\", cell);\r\n          if (window.gridComponent.state.previousVisualization) {\r\n            visualizeCell(\"num\", \"num num-visited\", cell);\r\n          }\r\n        }\r\n      }\r\n    }, 10 * i);\r\n  }\r\n}\r\n\r\nfunction animatePathSlow(cellsInOrder) {\r\n  for (let i = 0; i <= cellsInOrder.length; i++) {\r\n    setTimeout(() => {\r\n      if (i === cellsInOrder.length) {\r\n        window.gridComponent.setState({ status: \"finished\" });\r\n        return;\r\n      }\r\n      const cell = cellsInOrder[i];\r\n      if (!cell.start && !cell.end) {\r\n        visualizeCell(\"cell\", \"cell cell-path-animated\", cell);\r\n        if (window.gridComponent.state.previousVisualization) {\r\n          visualizeCell(\"num\", \"num num-path\", cell);\r\n        }\r\n      }\r\n    }, 20 * i);\r\n  }\r\n}\r\n\r\nexport function animateFast(visitedCells, cellsInOrder) {\r\n  for (let i = 0; i <= visitedCells.length - 1; i++) {\r\n    const cell = visitedCells[i];\r\n\r\n    if (cell.start && window.gridComponent.state.previousVisualization) {\r\n      visualizeCell(\"num\", \"num num-start\", cell);\r\n    } else if (cell.end) {\r\n      if (window.gridComponent.state.previousVisualization) {\r\n        visualizeCell(\"num\", \"num num-end\", cell);\r\n      }\r\n      animatePathFast(cellsInOrder);\r\n    } else if (!cell.isWall) {\r\n      if (!cell.start && !cell.end) {\r\n        visualizeCell(\"cell\", \"cell cell-visited\", cell);\r\n        if (window.gridComponent.state.previousVisualization) {\r\n          visualizeCell(\"num\", \"num num-visited\", cell);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction animatePathFast(cellsInOrder) {\r\n  for (let i = 0; i < cellsInOrder.length; i++) {\r\n    const cell = cellsInOrder[i];\r\n    if (!cell.start && !cell.end) {\r\n      visualizeCell(\"cell\", \"cell cell-path\", cell);\r\n      if (window.gridComponent.state.previousVisualization) {\r\n        visualizeCell(\"num\", \"num num-path\", cell);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function animateAstarSlow(allSet, cellsInOrder) {\r\n  for (let i = 0; i <= allSet.length; i++) {\r\n    if (i === allSet.length) {\r\n      setTimeout(() => {\r\n        animatePathSlow(cellsInOrder);\r\n      }, 10 * i);\r\n      return;\r\n    }\r\n    setTimeout(() => {\r\n      clearVisitedCells();\r\n      var openSet = allSet[i][0];\r\n      var closedSet = allSet[i][1];\r\n\r\n      for (let j = 0; j < closedSet.length; j++) {\r\n        if (!closedSet[j].start && !closedSet[j].end) {\r\n          visualizeCell(\"cell\", \"cell cell-previous\", closedSet[j]);\r\n        }\r\n      }\r\n      for (let k = 0; k < openSet.length; k++) {\r\n        if (!openSet[k].start && !openSet[k].end) {\r\n          visualizeCell(\"cell\", \"cell cell-current\", openSet[k]);\r\n        }\r\n      }\r\n      if (\r\n        i < allSet.length - 1 &&\r\n        !closedSet[closedSet.length - 1].start &&\r\n        !closedSet[closedSet.length - 1].end\r\n      ) {\r\n        visualizeCell(\r\n          \"cell\",\r\n          \"cell cell-activepath\",\r\n          closedSet[closedSet.length - 1]\r\n        );\r\n      }\r\n    }, 10 * i);\r\n  }\r\n}\r\n\r\nexport function animateAstarFast(allSet, openSet, cellsInOrder) {\r\n  clearVisitedCells();\r\n  for (let k = 0; k < allSet.length; k++) {\r\n    if (!allSet[k].start && !allSet[k].end) {\r\n      visualizeCell(\"cell\", \"cell cell-previous\", allSet[k]);\r\n    }\r\n  }\r\n  for (let k = 0; k < openSet.length; k++) {\r\n    if (!openSet[k].start && !openSet[k].end) {\r\n      visualizeCell(\"cell\", \"cell cell-current\", openSet[k]);\r\n    }\r\n  }\r\n  animatePathFast(cellsInOrder);\r\n}","import { animateFast, animateSlow } from \"./animations\";\r\nimport { getCellsInOrder } from \"../../Algorithms/methods\";\r\nimport { clearVisitedCells } from \"../../Algorithms/cleaning\";\r\nvar id = 0;\r\nexport function dijkstra(grid, startCell, endCell, isDiagonalOn, speed) {\r\n  const unvisitedCells = [];\r\n  const visitedCells = [];\r\n  var direction = \"START\";\r\n  var previousRow = startCell.row;\r\n  startCell.distance = 0;\r\n\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      unvisitedCells.push(cell);\r\n    }\r\n  }\r\n\r\n  while (!!unvisitedCells.length) {\r\n    unvisitedCells.sort((cell1, cell2) => cell1.id - cell2.id);\r\n    unvisitedCells.sort((cell1, cell2) => cell1.distance - cell2.distance);\r\n\r\n    const nextCell = unvisitedCells.shift();\r\n    if (direction !== \"START\") {\r\n      if (nextCell.row < previousRow) {\r\n        direction = \"UP\";\r\n      } else {\r\n        direction = \"DOWN\";\r\n      }\r\n    }\r\n\r\n    if (nextCell.isWall && !nextCell.start && !nextCell.end) continue;\r\n\r\n    if (nextCell.distance === Infinity) {\r\n      DoAnimation(visitedCells, endCell, speed);\r\n      return;\r\n    }\r\n    nextCell.visited = true;\r\n    visitedCells.push(nextCell);\r\n    if (nextCell === endCell) {\r\n      unvisitedCells.sort((cell1, cell2) => cell1.id - cell2.id);\r\n      DoAnimation(visitedCells, endCell, speed);\r\n      return;\r\n    }\r\n\r\n    getUnvisitedNeighbors(nextCell, grid, direction, isDiagonalOn);\r\n    if (direction !== \"START\") {\r\n      previousRow = nextCell.row;\r\n    }\r\n    direction = \"CHANGED\";\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(cell, grid, direction, isDiagonalOn) {\r\n  const neighbors = [];\r\n  var { col, row } = cell;\r\n\r\n  if (direction === \"DOWN\" || direction === \"START\") {\r\n    Up(row, col, grid, neighbors);\r\n    Right(row, col, grid, neighbors);\r\n    Down(row, col, grid, neighbors);\r\n    Left(row, col, grid, neighbors);\r\n    if (isDiagonalOn) {\r\n      UpRight(row, col, grid, neighbors);\r\n      RightDown(row, col, grid, neighbors);\r\n      DownLeft(row, col, grid, neighbors);\r\n      LeftUp(row, col, grid, neighbors);\r\n    }\r\n  } else if (direction === \"UP\") {\r\n    Down(row, col, grid, neighbors);\r\n    Left(row, col, grid, neighbors);\r\n    Up(row, col, grid, neighbors);\r\n    Right(row, col, grid, neighbors);\r\n    if (isDiagonalOn) {\r\n      DownLeft(row, col, grid, neighbors);\r\n      LeftUp(row, col, grid, neighbors);\r\n      UpRight(row, col, grid, neighbors);\r\n      RightDown(row, col, grid, neighbors);\r\n    }\r\n  }\r\n\r\n  for (const neighbor of neighbors) {\r\n    neighbor.distance = cell.distance + 1;\r\n    neighbor.previous = cell;\r\n    neighbor.id = id;\r\n    id++;\r\n  }\r\n}\r\n\r\nfunction Up(row, col, grid, neighbors) {\r\n  if (row > 0) {\r\n    var cell = grid[row - 1][col];\r\n    if (!cell.visited && cell.previous === null) {\r\n      neighbors.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\nfunction Right(row, col, grid, neighbors) {\r\n  if (col < grid[0].length - 1) {\r\n    let cell = grid[row][col + 1];\r\n    if (!cell.visited && cell.previous === null) {\r\n      neighbors.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\nfunction Down(row, col, grid, neighbors) {\r\n  if (row < grid.length - 1) {\r\n    let cell = grid[row + 1][col];\r\n    if (!cell.visited && cell.previous === null) {\r\n      neighbors.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\nfunction Left(row, col, grid, neighbors) {\r\n  if (col > 0) {\r\n    let cell = grid[row][col - 1];\r\n    if (!cell.visited && cell.previous === null) {\r\n      neighbors.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\nfunction UpRight(row, col, grid, neighbors) {\r\n  if (row > 0 && col < grid[0].length - 1) {\r\n    let cell = grid[row - 1][col + 1];\r\n    if (grid[row - 1][col].isWall && grid[row][col + 1].isWall) {\r\n      return;\r\n    }\r\n    if (!cell.visited && cell.previous === null) {\r\n      neighbors.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\nfunction RightDown(row, col, grid, neighbors) {\r\n  if (col < grid[0].length - 1 && row < grid.length - 1) {\r\n    let cell = grid[row + 1][col + 1];\r\n    if (grid[row + 1][col].isWall && grid[row][col + 1].isWall) {\r\n      return;\r\n    }\r\n    if (!cell.visited && cell.previous === null) {\r\n      neighbors.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\nfunction DownLeft(row, col, grid, neighbors) {\r\n  if (row < grid.length - 1 && col > 0) {\r\n    let cell = grid[row + 1][col - 1];\r\n    if (grid[row + 1][col].isWall && grid[row][col - 1].isWall) {\r\n      return;\r\n    }\r\n    if (!cell.visited && cell.previous === null) {\r\n      neighbors.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\nfunction LeftUp(row, col, grid, neighbors) {\r\n  if (col > 0 && row > 0) {\r\n    let cell = grid[row - 1][col - 1];\r\n    if (grid[row][col - 1].isWall && grid[row - 1][col].isWall) {\r\n      return;\r\n    }\r\n    if (!cell.visited && cell.previous === null) {\r\n      neighbors.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\nfunction DoAnimation(visitedCells, endCell, speed) {\r\n  const cellsInOrder = getCellsInOrder(endCell);\r\n  if (speed === \"slow\") {\r\n    if (window.gridComponent.state.status === \"finished\") {\r\n      clearVisitedCells();\r\n    }\r\n    window.gridComponent.setState({ status: \"running\" });\r\n\r\n    animateSlow(visitedCells, cellsInOrder);\r\n  } else if (speed === \"fast\") {\r\n    animateFast(visitedCells, cellsInOrder);\r\n  }\r\n}\r\n","import {\r\n  animateAstarSlow,\r\n  animateAstarFast,\r\n} from \"./animations\";\r\nimport { getCellsInOrder } from \"../../Algorithms/methods\";\r\nimport { clearVisitedCells } from \"../../Algorithms/cleaning\";\r\n\r\nexport function astar(\r\n  grid,\r\n  startCell,\r\n  endCell,\r\n  isDiagonalOn,\r\n  optimized,\r\n  speed\r\n) {\r\n  findNeighbors(grid, isDiagonalOn);\r\n  const openSet = [];\r\n  const cameFrom = [];\r\n  var allSet = [];\r\n  openSet.push(startCell);\r\n  startCell.g = 0;\r\n  startCell.f = heuristic(startCell, endCell, isDiagonalOn, optimized);\r\n\r\n  while (!!openSet.length) {\r\n    var current = 0;\r\n    for (let j = 0; j < openSet.length; j++) {\r\n      if (openSet[j].f < openSet[current].f) {\r\n        current = j;\r\n      }\r\n    }\r\n    var currentCell = openSet[current];    \r\n    if (currentCell === endCell) {\r\n      console.log(endCell.end);\r\n      DoAnimation(allSet, openSet, endCell, speed);\r\n      return;\r\n    }\r\n    eliminateFromSet(openSet, currentCell);\r\n    var neighbors = currentCell.neighbors;\r\n    for (let k = 0; k < neighbors.length; k++) {\r\n      var neighbor = neighbors[k];\r\n      if (neighbor.isWall && !neighbor.start && !neighbor.end) {\r\n        continue;\r\n      }\r\n      var tentative_gScore =\r\n        currentCell.g + dScore(neighbor, currentCell, optimized);\r\n      if (tentative_gScore < neighbor.g) {\r\n        cameFrom.push(neighbor);\r\n        neighbor.g = tentative_gScore;\r\n        neighbor.h = heuristic(neighbor, endCell, isDiagonalOn, optimized);\r\n        neighbor.f = neighbor.g + neighbor.h;\r\n        neighbor.previous = currentCell;\r\n        if (!openSet.includes(neighbor)) {\r\n          openSet.push(neighbor);\r\n          if (speed === \"slow\") {\r\n            allSet.push([openSet.slice(0), cameFrom.slice(0)]);\r\n          } else if (speed === \"fast\") {\r\n            allSet.push(neighbor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  DoAnimation(allSet, openSet, endCell, speed);\r\n}\r\nfunction dScore(cell1, cell2, optimized) {\r\n  if (optimized) {\r\n    return cell1.row - cell2.row === 0 || cell1.col - cell2.col === 0\r\n      ? 1\r\n      : Math.SQRT2;\r\n  } else {\r\n    return 1;\r\n  }\r\n}\r\n\r\nfunction heuristic(cell1, cell2, isDiagonalOn, optimized) {\r\n  if (isDiagonalOn || !optimized) {\r\n    return Math.abs(cell1.row - cell2.row) + Math.abs(cell1.col - cell2.col);\r\n  } else {\r\n    if (optimized) {\r\n      return Math.sqrt(\r\n        (cell1.row - cell2.row) * (cell1.row - cell2.row) +\r\n          (cell1.col - cell2.col) * (cell1.col - cell2.col)\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction findNeighbors(grid, isDiagonalOn) {\r\n  for (const row of grid) {\r\n    for (const cell of row) {\r\n      cell.neighbors = [];\r\n      if (cell.row > 0) {\r\n        //UP\r\n        cell.neighbors.push(grid[cell.row - 1][cell.col]);\r\n      }\r\n      if (cell.col < grid[0].length - 1) {\r\n        //RIGHT\r\n        cell.neighbors.push(grid[cell.row][cell.col + 1]);\r\n      }\r\n\r\n      if (cell.row < grid.length - 1) {\r\n        //DOWN\r\n        cell.neighbors.push(grid[cell.row + 1][cell.col]);\r\n      }\r\n\r\n      if (cell.col > 0) {\r\n        //LEFT\r\n        cell.neighbors.push(grid[cell.row][cell.col - 1]);\r\n      }\r\n      if (isDiagonalOn) {\r\n        if (cell.row > 0 && cell.col < grid[0].length - 1) {\r\n          //UPRIGHT\r\n          if (\r\n            !grid[cell.row - 1][cell.col].isWall ||\r\n            !grid[cell.row][cell.col + 1].isWall\r\n          ) {\r\n            cell.neighbors.push(grid[cell.row - 1][cell.col + 1]);\r\n          }\r\n        }\r\n        if (cell.col < grid[0].length - 1 && cell.row < grid.length - 1) {\r\n          //RIGHTDOWN\r\n          if (\r\n            !grid[cell.row + 1][cell.col].isWall ||\r\n            !grid[cell.row][cell.col + 1].isWall\r\n          ) {\r\n            cell.neighbors.push(grid[cell.row + 1][cell.col + 1]);\r\n          }\r\n        }\r\n        if (cell.row < grid.length - 1 && cell.col > 0) {\r\n          //DOWNLEFT\r\n          if (\r\n            !grid[cell.row + 1][cell.col].isWall ||\r\n            !grid[cell.row][cell.col - 1].isWall\r\n          ) {\r\n            cell.neighbors.push(grid[cell.row + 1][cell.col - 1]);\r\n          }\r\n        }\r\n        if (cell.col > 0 && cell.row > 0) {\r\n          //LEFTUP\r\n          if (\r\n            !grid[cell.row][cell.col - 1].isWall ||\r\n            !grid[cell.row - 1][cell.col].isWall\r\n          ) {\r\n            cell.neighbors.push(grid[cell.row - 1][cell.col - 1]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction eliminateFromSet(set, cell) {\r\n  for (let i = set.length - 1; i >= 0; i--) {\r\n    if (set[i] === cell) {\r\n      set.splice(i, 1);\r\n    }\r\n  }\r\n}\r\n\r\nfunction DoAnimation(allSet, openSet, endCell, speed) {\r\n  const cellsInOrder = getCellsInOrder(endCell);\r\n  if (speed === \"slow\") {\r\n    if (window.gridComponent.state.status === \"finished\") {\r\n      clearVisitedCells();\r\n    }\r\n    window.gridComponent.setState({ status: \"running\" });\r\n\r\n    animateAstarSlow(allSet, cellsInOrder);\r\n  } else if (speed === \"fast\") {\r\n    animateAstarFast(allSet, openSet, cellsInOrder);\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Cell from \"../Cell\";\r\nimport \"./index.css\";\r\nimport { createGrid, placeWall } from \"../Algorithms/methods\";\r\nimport { clearVisitedCells, clearWithStatus } from \"../Algorithms/cleaning\";\r\nimport { getRandomMazedGrid } from \"../Algorithms/mazes/default\";\r\nimport { primMaze } from \"../Algorithms/mazes/prim\";\r\nimport { iterativeMaze } from \"../Algorithms/mazes/iterative\";\r\nimport { aldousBroderMaze } from \"../Algorithms/mazes/aldousBroder\";\r\nimport { dijkstra } from \"../Algorithms/searchers/dijsktra\";\r\nimport { astar } from \"../Algorithms/searchers/astar\";\r\n\r\nclass Grid extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: createGrid(props),\r\n      isMouseDown: false,\r\n      isStartOn: false,\r\n      isEndOn: false,\r\n      startRow: props.startR,\r\n      startCol: props.startC,\r\n      endRow: props.endR,\r\n      endCol: props.endC,\r\n      status: \"pending\",\r\n      currentAlg: \"dijkstra\",\r\n      currentMaze: \"default\",\r\n      previousVisualization: false,\r\n      diagonalVisualization: true,\r\n      optimizedVisualization: true,\r\n    };\r\n    this.handleAlgoChange = this.handleAlgoChange.bind(this);\r\n    this.handleButtonChange = this.handleButtonChange.bind(this);\r\n    this.handleMazeChange = this.handleMazeChange.bind(this);\r\n    window.gridComponent = this;\r\n  }\r\n\r\n  handleAlgoChange(event) {\r\n    this.setState({ currentAlg: event.target.value });\r\n  }\r\n  handleButtonChange(event) {\r\n    if (event.target.name === \"distance\") {\r\n      this.setState(\r\n        { previousVisualization: !this.state.previousVisualization },\r\n        () => {\r\n          if (this.state.status === \"finished\") {\r\n            clearVisitedCells();\r\n            if (this.state.currentAlg === \"dijkstra\") {\r\n              this.doAlgorithm(\"fast\");\r\n            }\r\n          }\r\n        }\r\n      );\r\n    } else if (event.target.name === \"diagonal\") {\r\n      this.setState(\r\n        { diagonalVisualization: !this.state.diagonalVisualization },\r\n        () => {\r\n          if (this.state.status === \"finished\") {\r\n            clearVisitedCells();\r\n            this.doAlgorithm(\"fast\");\r\n          }\r\n        }\r\n      );\r\n    } else if (event.target.name === \"optimized\") {\r\n      this.setState(\r\n        { optimizedVisualization: !this.state.optimizedVisualization },\r\n        () => {\r\n          if (this.state.status === \"finished\") {\r\n            clearVisitedCells();\r\n            this.doAlgorithm(\"fast\");\r\n          }\r\n        }\r\n      );\r\n    }\r\n  }\r\n  handleMazeChange(event) {\r\n    if (event.target.value === \"random\") {\r\n      console.log(\"random\");\r\n      getRandomMazedGrid(this.state.grid);\r\n    } else if (event.target.value === \"prim\") {\r\n      console.log(\"prim\");\r\n      primMaze(this.state.grid);\r\n    } else if (event.target.value === \"iterative\") {\r\n      console.log(\"iterative\");\r\n      iterativeMaze(this.state.grid);\r\n    }else if (event.target.value === \"aldousBroder\") {\r\n      console.log(\"aldousBroder\");\r\n      aldousBroderMaze(this.state.grid);\r\n    }\r\n    \r\n    \r\n  }\r\n\r\n  onMouseDown = (cell) => {\r\n    if (this.state.status === \"running\") {\r\n      return;\r\n    }\r\n    this.setState({ isMouseDown: true });\r\n    if (cell.start) {\r\n      this.setState({ isStartOn: true });\r\n      return;\r\n    }\r\n    if (cell.end) {\r\n      this.setState({ isEndOn: true });\r\n      return;\r\n    }\r\n    placeWall(cell);\r\n  };\r\n\r\n  onMouseEnter = (cell) => {\r\n    if (this.state.isMouseDown) {\r\n      if (cell.start || cell.end) {\r\n        return;\r\n      }\r\n      if (this.state.isStartOn) {\r\n        let newGrid = this.state.grid.slice();\r\n        newGrid[this.state.startRow][this.state.startCol].start = false;\r\n        newGrid[cell.row][cell.col].start = true;\r\n        this.setState(\r\n          {\r\n            grid: newGrid,\r\n            startRow: cell.row,\r\n            startCol: cell.col,\r\n          },\r\n          () => {\r\n            if (this.state.status === \"finished\") {\r\n              clearVisitedCells();\r\n              this.doAlgorithm(\"fast\");\r\n            } else {\r\n              clearWithStatus(\"path\");\r\n            }\r\n          }\r\n        );\r\n        return;\r\n      } else if (this.state.isEndOn) {\r\n        let newGrid = this.state.grid.slice();\r\n        newGrid[this.state.endRow][this.state.endCol].end = false;\r\n        newGrid[cell.row][cell.col].end = true;\r\n        this.setState(\r\n          {\r\n            grid: newGrid,\r\n            endRow: cell.row,\r\n            endCol: cell.col,\r\n          },\r\n          () => {\r\n            if (this.state.status === \"finished\") {\r\n              clearVisitedCells();\r\n              this.doAlgorithm(\"fast\");\r\n            } else {\r\n              clearWithStatus(\"path\");\r\n            }\r\n          }\r\n        );\r\n        return;\r\n      }\r\n      placeWall(cell);\r\n    }\r\n  };\r\n  onMouseUp = () => {\r\n    this.setState({ isMouseDown: false, isStartOn: false, isEndOn: false });\r\n  };\r\n\r\n  doAlgorithm = (speed) => {\r\n    let { grid } = this.state;\r\n    const startCell = grid[this.state.startRow][this.state.startCol];\r\n    const endCell = grid[this.state.endRow][this.state.endCol];\r\n\r\n    if (this.state.currentAlg === \"dijkstra\") {\r\n      dijkstra(\r\n        grid,\r\n        startCell,\r\n        endCell,\r\n        this.state.diagonalVisualization,\r\n        speed\r\n      );\r\n    } else if (this.state.currentAlg === \"astar\") {\r\n      astar(\r\n        grid,\r\n        startCell,\r\n        endCell,\r\n        this.state.diagonalVisualization,\r\n        this.state.optimizedVisualization,\r\n        speed\r\n      );\r\n    }\r\n  };\r\n\r\n  render() {\r\n    let grid = this.state.grid.map((row, index) => {\r\n      return (\r\n        <div key={index} className=\"row\">\r\n          {row.map((cell, cellIndex) => {\r\n            return (\r\n              <Cell\r\n                key={cellIndex}\r\n                data={cell}\r\n                onMouseDown={this.onMouseDown}\r\n                onMouseEnter={this.onMouseEnter}\r\n                onMouseUp={this.onMouseUp}\r\n              />\r\n            );\r\n          })}\r\n        </div>\r\n      );\r\n    });\r\n    return (\r\n      <div>\r\n        <div className=\"grid\" onMouseLeave={this.onMouseUp}>\r\n          {grid}\r\n        </div>\r\n        <select\r\n          value={this.state.currentAlg}\r\n          onChange={this.handleAlgoChange}\r\n          disabled={this.state.status === \"running\"}\r\n        >\r\n          <option value=\"dijkstra\">Dijkstra</option>\r\n          <option value=\"astar\">A* Search</option>\r\n        </select>\r\n        <button\r\n          disabled={this.state.status === \"running\"}\r\n          onClick={() => this.doAlgorithm(\"slow\")}\r\n        >\r\n          Start\r\n        </button>\r\n        <button\r\n          disabled={this.state.status === \"running\"}\r\n          onClick={() => {\r\n            clearWithStatus(\"path\");\r\n          }}\r\n        >\r\n          Clear path\r\n        </button>\r\n        <button\r\n          disabled={this.state.status === \"running\"}\r\n          onClick={() => {\r\n            clearWithStatus(\"grid\");\r\n          }}\r\n        >\r\n          Clear grid\r\n        </button>\r\n        Distance\r\n        <label className=\"switch\">\r\n          <input\r\n            disabled={\r\n              this.state.status === \"running\" ||\r\n              this.state.currentAlg === \"astar\"\r\n            }\r\n            type=\"checkbox\"\r\n            defaultChecked={this.state.previousVisualization}\r\n            onChange={this.handleButtonChange}\r\n            name=\"distance\"\r\n          ></input>\r\n          <span className=\"slider round\"></span>\r\n        </label>\r\n        Diagonal\r\n        <label className=\"switch\">\r\n          <input\r\n            disabled={this.state.status === \"running\"}\r\n            type=\"checkbox\"\r\n            defaultChecked={this.state.diagonalVisualization}\r\n            onChange={this.handleButtonChange}\r\n            name=\"diagonal\"\r\n          ></input>\r\n          <span className=\"slider round\"></span>\r\n        </label>\r\n        Optimized\r\n        <label className=\"switch\">\r\n          <input\r\n            disabled={\r\n              this.state.status === \"running\" ||\r\n              this.state.currentAlg === \"dijkstra\"\r\n            }\r\n            type=\"checkbox\"\r\n            defaultChecked={this.state.optimizedVisualization}\r\n            onChange={this.handleButtonChange}\r\n            name=\"optimized\"\r\n          ></input>\r\n          <span className=\"slider round\"></span>\r\n        </label>\r\n        <select\r\n          value={this.state.currentMaze}\r\n          onChange={this.handleMazeChange}\r\n          disabled={this.state.status === \"running\"}\r\n        >\r\n          <option value=\"default\" disabled hidden>\r\n            Mazes\r\n          </option>\r\n          <option value=\"random\">Random</option>\r\n          <option value=\"prim\">Prim</option>\r\n          <option value=\"iterative\">Iterative</option>\r\n          <option value=\"aldousBroder\">Aldous-Broder</option>\r\n        </select>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Grid;\r\n","import React, { Component } from \"react\";\r\nimport Grid from \"../../path-finder/src/Grid\";\r\n\r\nclass App extends Component {\r\n  constructor(props) {\r\n    super();\r\n    this.state = {\r\n      rows: this.getSize(\"row\"),\r\n      columns: this.getSize(\"col\"),\r\n      startR: this.getPosition(\"row\"),\r\n      startC: this.getPosition(\"startCol\"),\r\n      endR: this.getPosition(\"row\"),\r\n      endC: this.getPosition(\"endCol\"),\r\n    };\r\n  }\r\n\r\n  getPosition = (parameter) => {\r\n    let position = null;\r\n    if (parameter === \"row\") {\r\n      position = Math.floor(this.getSize(\"row\") / 2);\r\n    } else if (parameter === \"startCol\") {\r\n      position = Math.floor(this.getSize(\"col\") / 5);\r\n    } else if (parameter === \"endCol\") {\r\n      let x = this.getSize(\"col\");\r\n      let margin = Math.ceil(x / 5);\r\n      position = x - margin;\r\n    }\r\n    return position % 2 === 0 ? position + 1 : position;\r\n    // return position;\r\n  };\r\n\r\n  getSize = (type) => {\r\n    let size = null;\r\n    if (type === \"row\") {\r\n      size = (window.innerHeight / 30).toFixed(0) - 5;\r\n      if (size < 10) {\r\n        return 9;\r\n      }\r\n    } else if (type === \"col\") {\r\n      size = (window.innerWidth / 30).toFixed(0) - 5;\r\n      if (size < 10) {\r\n        return 9;\r\n      }\r\n    }\r\n    if (size % 2 === 0) {\r\n      size--;\r\n    }\r\n    return size;\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"App\">\r\n        <Grid\r\n          rows={this.state.rows}\r\n          columns={this.state.columns}\r\n          startR={this.state.startR}\r\n          startC={this.state.startC}\r\n          endR={this.state.endR}\r\n          endC={this.state.endC}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n}\r\nexport default App;\r\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}